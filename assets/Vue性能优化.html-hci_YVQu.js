import{_ as c,r as p,o as s,c as t,b as e,d as o,a,e as d}from"./app-quQJY7jk.js";const r={},l=d(`<p><strong>模板尽可能少得使用表达示</strong></p><p>模板中表达式过多时(如<code>v-if=&quot;isShow &amp;&amp; hasRight &amp;&amp; (foo || bar)&quot;</code>)，适当的封装成<code>computed</code></p><p><strong>不同时使用<code>v-for</code>和<code>v-if</code></strong></p><p><code>v-for</code> 具有比 <code>v-if</code> 更高的优先级，应当先对循环的内容作用 <code>v-if</code> 条件的过滤，减少不必要的循环</p><p><strong>频繁的切换显示使用<code>v-show</code></strong></p><p><strong>动态加载模块</strong></p><p><strong>异步加载组件</strong></p><p><strong>在动态组件上使用 keep-alive</strong></p><p>使用动态组件时，反复的切换组件会造成组件重新渲染，使用 <code>keep-alive</code> 可以缓存失活的组件，更加高效复用组件</p><p><strong>列表渲染添加key</strong></p><p><strong>Object.freeze</strong></p><p>对于只纯展示的数据，就不需要对这个数进行监听了，此时可以使用 <code>Object.freeze</code> 方法冻结一个对象</p><p><strong>图片资源懒加载</strong></p><p><code>vue-lazyload 插件</code></p><p><strong>预取/预加载模块(prefetch/preload module)</strong></p><p>在声明 <code>import</code> 时，使用下面这些内置指令，可以让 webpack 输出 &quot;resource hint(资源提示)&quot;，来告知浏览器：</p><ul><li><p><code>prefetch</code>(预取)：将来某些导航下可能需要的资源</p></li><li><p><code>preload</code>(预加载)：当前导航下可能需要资源</p></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPrefetch: true */</span> <span class="token string">&#39;LoginModal&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPreload: true */</span> <span class="token string">&#39;ChartingLibrary&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这会生成 <code>&lt;link rel=&quot;prefetch&quot; href=&quot;login-modal-chunk.js&quot;&gt;</code> 并追加到页面头部，指示着浏览器在闲置时间预取 <code>login-modal-chunk.js</code> 文件</p><p>只要父 chunk 完成加载，webpack 就会添加 prefetch hint(预取提示)</p><p>与 prefetch 指令相比，preload 指令有许多不同之处：</p><ul><li><p><code>preload chunk</code> 会在父 <code>chunk</code> 加载时，以并行方式开始加载。<code>prefetch chunk</code> 会在父 <code>chunk</code> 加载结束后开始加载</p></li><li><p><code>prefetch chunk</code> 在浏览器闲置时下载</p></li></ul>`,22),i={href:"https://www.googlespeed.cn/?spm=a2c4e.10696291.0.0.6e4919a4XKVOUm&url=www.zhujizhou.com",target:"_blank",rel:"noopener noreferrer"},u=e("p",null,[e("strong",null,[o("巧用"),e("code",null,'<div id="app"></div>'),o("进行白屏优化")])],-1),h=e("p",null,"首次渲染会有一段时间的白屏原因是首次渲染时需要加载一堆资源，如js、css、图片。很多优化策略，最终目的是提高这些资源的加载速度。 但是如果遇上网络慢的情况，无论优化到极致还是需要一定加载时间，这时就会出现白屏现象",-1),g=e("p",null,[o("如果 "),e("code",null,'<div id="app"></div>'),o(" 里面有内容，就不会出现白屏。所以我们可以在 "),e("code",null,'<div id="app"></div>'),o(" 里添加首屏的静态页面。 等真正的首屏加载出来后就会把 "),e("code",null,'<div id="app"></div>'),o(" 这块结构都替换掉，给人一种视觉上的误差，就不会产生白屏")],-1);function k(v,m){const n=p("ExternalLinkIcon");return s(),t("div",null,[l,e("p",null,[e("a",i,[o("项目性能评测"),a(n)])]),u,h,g])}const f=c(r,[["render",k],["__file","Vue性能优化.html.vue"]]);export{f as default};
