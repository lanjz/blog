(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{592:function(t,s,a){t.exports=a.p+"assets/img/f.af1f97ee.png"},593:function(t,s,a){t.exports=a.p+"assets/img/fiber.85707628.jpg"},594:function(t,s,a){t.exports=a.p+"assets/img/f_4.2cd974d4.jpeg"},595:function(t,s,a){t.exports=a.p+"assets/img/f_5.5b01493d.jpeg"},820:function(t,s,a){"use strict";a.r(s);var e=a(58),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"fiber"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[t._v("#")]),t._v(" Fiber")]),t._v(" "),e("p",[t._v("Fiber 就是 React 16 实现的一套新的更新机制，让 React 的更新过程变得可控，避免了之前采用递归需要一气呵成影响性能的做法")]),t._v(" "),e("h2",{attrs:{id:"react-瓶颈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-瓶颈"}},[t._v("#")]),t._v(" React 瓶颈")]),t._v(" "),e("p",[e("strong",[t._v("React 的核心思想：")]),t._v(" 内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中")]),t._v(" "),e("p",[t._v("React 追求的是 “快速响应”，那么，“快速响应“的制约因素都有什么呢？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("CPU的瓶颈：当项目变得庞大、组件数量繁多、遇到大计算量的操作或者设备性能不足使得页面掉帧，导致卡顿")])]),t._v(" "),e("li",[e("p",[t._v("IO的瓶颈：发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应")])])]),t._v(" "),e("p",[t._v("这两个问题一直也是最影响前端开发体验的地方，一个会造成卡顿，一个会造成白屏，本文要聊的fiber 架构主要就是用来解决 CPU的瓶颈")]),t._v(" "),e("h3",{attrs:{id:"vs-vue3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vs-vue3"}},[t._v("#")]),t._v(" vs Vue3")]),t._v(" "),e("p",[e("strong",[t._v("Vue3")])]),t._v(" "),e("p",[t._v("Vue3.0 提出动静结合的 DOM diff 思想，动静结合的 DOM diff 其实是在预编译阶段进行了优化。之所以能够做到预编译优化，是因为 Vue core 可以静态分析 template，在解析模版时，整个 parse 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签和文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。")]),t._v(" "),e("p",[t._v("借助静态编译过程，Vue 可以做很多优化。比如在预编译时标记出模版中的动态节点和静态节点，再次进行渲染前 diff 时就可以跳过“永远不会变化的节点”，而只需要对比“可能会变化的动态节点”。从而提高了 diff 和组件更新的效率")]),t._v(" "),e("p",[e("strong",[t._v("React")])]),t._v(" "),e("p",[t._v("而 React 就是局部重新渲染，React 拿到的或者说掌管的，所负责的就是一堆递归 "),e("code",[t._v("React.createElement")]),t._v(" 的执行调用（参考下方经过Babel转换的代码），它无法从模版层面进行静态分析。JSX 和手写的 "),e("code",[t._v("render function")]),t._v(" 是完全动态的，过度的灵活性导致运行时可以用于优化的信息不足。")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//JSX 写法：")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("六个问题助你理解 React Fiber"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ul"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("React"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("Vue"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ul"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),e("p",[t._v("递归 React.createElement：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Babel转换后")]),t._v("\nReact"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"div"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n React"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"h1"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\u516D\\u4E2A\\u95EE\\u9898\\u52A9\\u4F60\\u7406\\u89E3 React Fiber"')]),t._v("\n "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n React"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ul"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n   React"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"li"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"React"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n   React"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"li"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Vue"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[e("strong",[t._v("template vs jsx")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("JSX 具有 JavaScript 的完整表现力，可以构建非常复杂的组件。但是灵活的语法，也意味着引擎难以理解，无法预判开发者的用户意图，从而难以优化性能")])]),t._v(" "),e("li",[e("p",[t._v("Template 模板是一种非常有约束的语言，你只能以某种方式去编写模板。")])])]),t._v(" "),e("h3",{attrs:{id:"react-15-架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-15-架构"}},[t._v("#")]),t._v(" React 15 架构")]),t._v(" "),e("p",[t._v("React15架构可以分为两层：")]),t._v(" "),e("p",[t._v("Reconciler（协调器）—— React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去")]),t._v(" "),e("p",[t._v("Renderer（渲染器）—— 遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。")]),t._v(" "),e("p",[t._v("在React15及以前，Reconciler 采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了16ms，用户交互就会卡顿。")]),t._v(" "),e("p",[t._v("为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。")]),t._v(" "),e("h3",{attrs:{id:"react-16-架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-16-架构"}},[t._v("#")]),t._v(" React 16 架构")]),t._v(" "),e("p",[t._v("为了解决同步更新长时间占用线程导致页面卡顿的问题，也为了探索运行时优化的更多可能，React开始重构并一直持续至今。重构的目标是实现Concurrent Mode（并发模式）。")]),t._v(" "),e("p",[t._v("从v15到v16，React团队花了两年时间将源码架构中的 Stack Reconciler 重构为 Fiber Reconciler")]),t._v(" "),e("p",[t._v("React16架构可以分为三层：")]),t._v(" "),e("p",[t._v("Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler")]),t._v(" "),e("p",[t._v("Reconciler（协调器）—— 负责找出变化的组件：更新工作从递归变成了可以中断的循环过程Reconciler内部采用了Fiber的架构")]),t._v(" "),e("p",[t._v("Renderer（渲染器）—— 负责将变化的组件渲染到页面上")]),t._v(" "),e("h3",{attrs:{id:"react-17-优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-17-优化"}},[t._v("#")]),t._v(" React 17 优化")]),t._v(" "),e("p",[t._v("React16的 expirationTimes模型 只能区分是否 "),e("code",[t._v(">=expirationTimes")]),t._v(" 决定节点是否更新。React17的 lanes模型 可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("p",[t._v("Lane用二进制位表示任务的优先级，方便优先级的计算（位运算），不同优先级占用不同位置的“赛道”，而且存在批的概念，优先级越低，“赛道”越多。高优先级打断低优先级，新建的任务需要赋予什么优先级等问题都是Lane所要解决的问题")])]),t._v(" "),e("p",[t._v("Concurrent Mode的目的是实现一套可中断/恢复的更新机制。其由两部分组成：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("一套协程架构：Fiber Reconciler")])]),t._v(" "),e("li",[e("p",[t._v("基于协程架构的启发式更新算法：控制协程架构工作方式的算法")])])]),t._v(" "),e("p",[t._v("为了解决之前提到解决方案遇到的问题，提出了以下几个目标：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("暂停工作，稍后再回来。")])]),t._v(" "),e("li",[e("p",[t._v("为不同类型的工作分配优先权。")])]),t._v(" "),e("li",[e("p",[t._v("重用以前完成的工作。")])]),t._v(" "),e("li",[e("p",[t._v("如果不再需要，则中止工作。")])])]),t._v(" "),e("p",[t._v("为了做到这些，我们首先需要一种方法将任务分解为单元。从某种意义上说，这就是 Fiber，Fiber 代表一种工作单元")]),t._v(" "),e("p",[t._v("但是仅仅是分解为单元也无法做到中断任务，因为函数调用栈就是这样，每个函数为一个工作，每个工作被称为堆栈帧，它会一直工作，直到堆栈为空，无法中断")]),t._v(" "),e("p",[t._v("所以我们需要一种增量渲染的调度，那么就需要重新实现一个堆栈帧的调度，这个堆栈帧可以按照自己的调度算法执行他们。另外由于这些堆栈是可以自己控制的，所以可以加入并发或者错误边界等功能。")]),t._v(" "),e("p",[t._v("因此 Fiber 就是重新实现的堆栈帧，本质上 Fiber 也可以理解为是一个虚拟的堆栈帧，将可中断的任务拆分成多个子任务，通过按照优先级来自由调度子任务，分段更新，从而将之前的同步渲染改为异步渲染")]),t._v(" "),e("p",[t._v("所以我们可以说 Fiber 是一种数据结构(堆栈帧)，也可以说是一种解决可中断的调用任务的一种解决方案，它的特性就是时间分片(time slicing)和暂停(supense)。")]),t._v(" "),e("h2",{attrs:{id:"什么是-fiber"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-fiber"}},[t._v("#")]),t._v(" 什么是 Fiber")]),t._v(" "),e("p",[t._v("Fiber 是 React 的最小工作单元，在理解 Fiber 之前，先梳理一下 Fiber 与 "),e("code",[t._v("ReactElement")]),t._v("、 DOM 对象之间的关系")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("ReactElement 对象: 所有采用 jsx 语法书写的节点, 都会被编译器转换, 最终会以 "),e("code",[t._v("React.createElement(...)")]),t._v(" 的方式创建出来一个与之对应的 "),e("code",[t._v("ReactElement")]),t._v("对象")])]),t._v(" "),e("li",[e("p",[t._v("fiber 对象: fiber 对象是通过 "),e("code",[t._v("ReactElement对象")]),t._v(" 进行创建的, 多个 "),e("code",[t._v("fiber对象")]),t._v(" 构成了一棵 "),e("code",[t._v("fiber树")]),t._v(", "),e("code",[t._v("fiber树")]),t._v(" 是构造 DOM 树的数据模型, "),e("code",[t._v("fiber树")]),t._v(" 的任何改动, 最后都体现到 DOM 树")])]),t._v(" "),e("li",[e("p",[t._v("DOM 对象: 最终要呈现的目标也就是文档对象模型")])])]),t._v(" "),e("p",[t._v("eg:")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("App")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div className"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"app"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("header"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("header"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("header"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Content "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("footer"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("footer"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("footer"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Content")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("React"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Fragment"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("p"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("p"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("p"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("p"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("p"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("p"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("React"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Fragment"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" App"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("上面 JSX 代码到 DOM 节点的转换过程:")]),t._v(" "),e("p",[e("img",{attrs:{src:a(592),alt:""}})]),t._v(" "),e("p",[t._v("小结：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("平时书写的 JSX, 也就是 "),e("code",[t._v("ReactElement对象")])])]),t._v(" "),e("li",[e("p",[e("code",[t._v("fiber 树")]),t._v("是通过 "),e("code",[t._v("ReactElement")]),t._v(" 生成的, 如果脱离了 "),e("code",[t._v("ReactElement")]),t._v(" , "),e("code",[t._v("fiber树")]),t._v("也无从谈起. 所以是 "),e("code",[t._v("ReactElement树")]),t._v(" (不是严格的树结构, 为了方便也称为树)驱动 "),e("code",[t._v("fiber树")]),t._v(".")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("fiber树")]),t._v(" 是 DOM 树的数据模型, "),e("code",[t._v("fiber树")]),t._v(" 驱动 DOM 树")])])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 源码定义：")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("FiberNode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("tag"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" WorkTag"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  pendingProps"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" mixed"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  key"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" string"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  mode"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" TypeOfMode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Fiber元素的静态属性相关")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("tag "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tag"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("key "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// fiber的key")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("elementType "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("type "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// fiber对应的DOM元素的标签类型，div、p...")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stateNode "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// fiber的实例，类组件场景下，是组件的类，HostComponent场景，是dom元素")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Fiber 链表相关")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("return "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向父级fiber")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("child "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向子fiber")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sibling "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 同级兄弟fiber")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("index "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ref "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ref相关")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Fiber更新相关")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pendingProps "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pendingProps"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("memoizedProps "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("updateQueue "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 存储update的链表")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("memoizedState "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 类组件存储fiber的状态，函数组件存储hooks链表")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dependencies "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("mode "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Effects")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// flags原为effectTag，表示当前这个fiber节点变化的类型：增、删、改")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("flags "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" NoFlags"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nextEffect "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// effect链相关，也就是那些需要更新的fiber节点")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("firstEffect "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastEffect "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lanes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" NoLanes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 该fiber中的优先级，它可以判断当前节点是否需要更新")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("childLanes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" NoLanes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子树中的优先级，它可以判断当前节点的子树是否需要更新")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n  * 可以看成是workInProgress（或current）树中的和它一样的节点，\n  * 可以通过这个字段是否为null判断当前这个fiber处在更新还是创建过程\n  * */")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("alternate "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h2",{attrs:{id:"fiber树的结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber树的结构"}},[t._v("#")]),t._v(" Fiber树的结构")]),t._v(" "),e("p",[t._v("从上的源码中可以看到一个 fiber 节点包含了很多属性，这里先看以下几个属性：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Type："),e("code",[t._v("<div>")]),t._v(", "),e("code",[t._v("<span>")]),t._v(", 原生标签等. 及 react 中的 "),e("code",[t._v("宿主组件 (string)")]),t._v(", "),e("code",[t._v("类")]),t._v(" 或者 "),e("code",[t._v("函数复合组件")])])]),t._v(" "),e("li",[e("p",[t._v("Child：指向子fiber")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Name")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div className"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"name"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("props"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[e("code",[t._v("<Name>")]),t._v(" 组件的 "),e("code",[t._v("child")]),t._v(" 就是返回的 "),e("code",[t._v("<div>")])])]),t._v(" "),e("li",[e("p",[t._v("Sibling: 同级兄弟fiber")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Name")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Customdiv1 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Customdiv2 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[e("code",[t._v("<Customdiv1>")]),t._v(" "),e("code",[t._v("sibling")]),t._v(" 就是返回的 "),e("code",[t._v("<Customdiv2 />")])])]),t._v(" "),e("li",[e("p",[t._v("Return: 返回给父 fiber 节点")])])]),t._v(" "),e("p",[t._v("通过以上属性串联各个 fiber 形成 fiber 树, 所以 fiber 树是一个类似单向链表的结构")]),t._v(" "),e("p",[e("img",{attrs:{src:a(593),alt:""}})]),t._v(" "),e("h2",{attrs:{id:"vs-virtual-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vs-virtual-dom"}},[t._v("#")]),t._v(" vs Virtual Dom")]),t._v(" "),e("p",[t._v("Virtual Dom 是对 渲染的 Dom 结构的对象表示，Fiber是对Virtual DOM的一种升级")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Virtual DOM使用栈来调度需要更新的内容，中间无法中断、暂停。Fiber支持中断，在浏览器渲染帧里面分片执行更新任务")])]),t._v(" "),e("li",[e("p",[t._v("Fiber结构让虚拟节点记录父节点、兄弟节点、子节点，形成链表树，你可以从任意顶点遍历到任意子节点，并返回")])]),t._v(" "),e("li",[e("p",[t._v("Fiber的分片操作使用 "),e("code",[t._v("requestAnimationFrame")]),t._v("(高优先级任务)和 "),e("code",[t._v("requestIdleCallback")]),t._v(" (低优先级任务)")])]),t._v(" "),e("li",[e("p",[t._v("Fiber 对任务的执行优先级进行标记，高优先级的任务可以先执行，实现架构上的无阻塞")])])]),t._v(" "),e("h2",{attrs:{id:"fiber-更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber-更新"}},[t._v("#")]),t._v(" Fiber 更新")]),t._v(" "),e("p",[e("strong",[t._v("Fiber 是如何工作的")])]),t._v(" "),e("p",[t._v("当执行 "),e("code",[t._v("ReactDOM.render()")]),t._v(" 和 "),e("code",[t._v("setState")]),t._v(" 时更新步骤如下：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("将创建的更新加入任务队列，等待调度")])]),t._v(" "),e("li",[e("p",[t._v("在 "),e("code",[t._v("requestIdleCallback")]),t._v(" 空闲时执行任务")])]),t._v(" "),e("li",[e("p",[t._v("从根节点开始遍历 Fiber Node，并且构建 WokeInProgress Tree")])]),t._v(" "),e("li",[e("p",[t._v("生成 effectList。")])]),t._v(" "),e("li",[e("p",[t._v("根据 EffectList 更新 DOM")])])]),t._v(" "),e("p",[t._v("下面是一个详细的执行过程图：")]),t._v(" "),e("p",[e("img",{attrs:{src:a(594),alt:""}})]),t._v(" "),e("ol",[e("li",[e("p",[t._v("第一部分从 "),e("code",[t._v("ReactDOM.render()")]),t._v(" 方法开始，把接收的 React Element 转换为 Fiber 节点，并为其设置优先级，创建 Update，加入到更新队列，这部分主要是做一些初始数据的准备。")])]),t._v(" "),e("li",[e("p",[t._v("第二部分主要是三个函数：scheduleWork、requestWork、performWork，即安排工作、申请工作、正式工作三部曲，React 16 新增的异步调用的功能则在这部分实现，这部分就是 Schedule 阶段，在这个获取到可执行的时间片，第三部分才会继续执行。具体是如何调度的，后面文章再介绍，这是 React 调度的关键过程。")])]),t._v(" "),e("li",[e("p",[t._v("第三部分是一个大循环，遍历所有的 Fiber 节点，通过 Diff 算法计算所有更新工作，产出 EffectList 给到 commit 阶段使用，这部分的核心是 beginWork 函数，这部分基本就是 Fiber Reconciler ，包括 reconciliation 和 commit 阶段。")])])]),t._v(" "),e("h2",{attrs:{id:"fiber-node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber-node"}},[t._v("#")]),t._v(" Fiber Node")]),t._v(" "),e("p",[t._v("FIber Node，承载了非常关键的上下文信息，可以说是贯彻整个创建和更新的流程，下来分组列了一些重要的 Fiber 字段")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v(" \n "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点） ")]),t._v("\n stateNode"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 单链表树结构")]),t._v("\n "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回 ")]),t._v("\n child"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向自己的第一个子节点")]),t._v("\n sibling"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点  ")]),t._v("\n "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 更新相关 ")]),t._v("\n pendingProps"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新的变动带来的新的props")]),t._v("\n memoizedProps"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上一次渲染完成之后的props")]),t._v("\n updateQueue"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" UpdateQueue"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 该Fiber对应的组件产生的Update会存放在这个队列里面 ")]),t._v("\n  memoizedState"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上一次渲染的时候的state ")]),t._v("\n "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Scheduler 相关")]),t._v("\n expirationTime"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ExpirationTime"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代表任务在未来的哪个时间点应该被完成，不包括他的子树产生的任务  // 快速确定子树中是否有不在等待的变化")]),t._v("\n childExpirationTime"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ExpirationTime"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber ")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 我们称他为`current <==> workInProgress`")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在渲染完成之后他们会交换位置 ")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// alternate: Fiber | null,  ")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Effect 相关的 ")]),t._v("\n effectTag"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" SideEffectTag"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用来记录Side Effect ")]),t._v("\n  nextEffect"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 单链表用来快速查找下一个side effect")]),t._v("\n  firstEffect"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子树中第一个side effect  ")]),t._v("\n  lastEffect"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子树中最后一个side effect ")]),t._v("\n "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("h3",{attrs:{id:"fiber-reconciler"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber-reconciler"}},[t._v("#")]),t._v(" Fiber Reconciler")]),t._v(" "),e("p",[t._v("在第二部分，进行 Schedule 完，获取到时间片之后，就开始进行 reconcile。")]),t._v(" "),e("p",[t._v("Fiber Reconciler 是 React 里的调和器，这也是任务调度完成之后，如何去执行每个任务，如何去更新每一个节点的过程，对应上面的第三部分。")]),t._v(" "),e("p",[t._v("reconcile 过程分为2个阶段（phase）：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("（可中断）render/reconciliation 通过构造 WorkInProgress Tree 得出 Change。")])]),t._v(" "),e("li",[e("p",[t._v("（不可中断）commit 应用这些DOM change。")])])]),t._v(" "),e("h3",{attrs:{id:"reconciliation-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reconciliation-阶段"}},[t._v("#")]),t._v(" reconciliation 阶段")]),t._v(" "),e("p",[t._v("在 reconciliation 阶段的每个工作循环中，每次处理一个 Fiber，处理完可以中断/挂起整个工作循环。通过每个节点更新结束时向上归并 Effect List 来收集任务结果，reconciliation 结束后，根节点的 Effect List里记录了包括 DOM change 在内的所有 Side Effect")]),t._v(" "),e("p",[t._v("render 阶段可以理解为就是 Diff 的过程，得出 Change(Effect List)，会执行声明如下的声明周期方法：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("[UNSAFE_]componentWillMount（弃用）")])]),t._v(" "),e("li",[e("p",[t._v("[UNSAFE_]componentWillReceiveProps（弃用）")])]),t._v(" "),e("li",[e("p",[t._v("getDerivedStateFromProps")])]),t._v(" "),e("li",[e("p",[t._v("shouldComponentUpdate")])]),t._v(" "),e("li",[e("p",[t._v("[UNSAFE_]componentWillUpdate（弃用）")])]),t._v(" "),e("li",[e("p",[t._v("render")])])]),t._v(" "),e("p",[t._v("由于 reconciliation 阶段是可中断的，一旦中断之后恢复的时候又会重新执行，所以很可能 reconciliation 阶段的生命周期方法会被多次调用，所以在 reconciliation 阶段的生命周期的方法是不稳定的，我想这也是 React 为什么要废弃 "),e("code",[t._v("componentWillMount")]),t._v(" 和 "),e("code",[t._v("componentWillReceiveProps")]),t._v(" 方法而改为静态方法 "),e("code",[t._v("getDerivedStateFromProps")]),t._v(" 的原因吧。")]),t._v(" "),e("h3",{attrs:{id:"commit-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#commit-阶段"}},[t._v("#")]),t._v(" commit 阶段")]),t._v(" "),e("p",[t._v("commit 阶段可以理解为就是将 Diff 的结果反映到真实 DOM 的过程")]),t._v(" "),e("p",[t._v("在 commit 阶段，在 commitRoot 里会根据 effect的 effectTag，具体 effectTag 见源码 ，进行对应的插入、更新、删除操作，根据 tag 不同，调用不同的更新方法")]),t._v(" "),e("p",[t._v("commit 阶段会执行如下的声明周期方法")]),t._v(" "),e("p",[t._v("getSnapshotBeforeUpdate\ncomponentDidMount\ncomponentDidUpdate\ncomponentWillUnmount")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("p",[t._v("注意区别 reconciler、reconcile 和 reconciliation，reconciler 是调和器，是一个名词，可以说是 React 工作的一个模块，协调模块；reconcile 是调和器调和的动作，是一个动词；而 reconciliation 只是 reconcile 过程的第一个阶段。")])]),t._v(" "),e("h3",{attrs:{id:"fiber-tree-和-workinprogress-tree"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fiber-tree-和-workinprogress-tree"}},[t._v("#")]),t._v(" Fiber Tree 和 WorkInProgress Tree")]),t._v(" "),e("p",[t._v("React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为 current 树（当前树，记录当前页面的状态）。")]),t._v(" "),e("p",[t._v("在后续的更新过程中（setState），每次重新渲染都会重新创建 Element, 但是 Fiber 不会，Fiber 只会使用对应的 Element 中的数据来更新自己必要的属性，")]),t._v(" "),e("p",[t._v("Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复")]),t._v(" "),e("p",[t._v("每一个 Fiber Node 节点与 Virtual Dom 一一对应，所有 Fiber Node 连接起来形成 Fiber tree, 是个单链表树结构，如下图所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:a(595),alt:""}})]),t._v(" "),e("p",[e("strong",[t._v("当 render 的时候有了这么一条单链表，当调用 setState 的时候又是如何 Diff 得到 change 的呢？")])]),t._v(" "),e("p",[t._v("采用的是一种叫双缓冲技术（double buffering），这个时候就需要另外一颗树：WorkInProgress Tree，它反映了要刷新到屏幕的未来状态")]),t._v(" "),e("p",[t._v("WorkInProgress Tree 构造完毕，得到的就是新的 Fiber Tree，然后喜新厌旧（把 current 指针指向WorkInProgress Tree，丢掉旧的 Fiber Tree）就好了")]),t._v(" "),e("p",[t._v("这样做的好处：")]),t._v(" "),e("p",[t._v("能够复用内部对象（fiber）\n节省内存分配、GC的时间开销\n就算运行中有错误，也不会影响 View 上的数据")]),t._v(" "),e("p",[t._v("每个 Fiber上都有个alternate属性，也指向一个 Fiber，创建 WorkInProgress 节点时优先取alternate，没有的话就创建一个")]),t._v(" "),e("p",[t._v("创建 WorkInProgress Tree 的过程也是一个 Diff 的过程，Diff 完成之后会生成一个 Effect List，这个 Effect List 就是最终 Commit 阶段用来处理副作用的阶段")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/98295862",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入理解 React Fiber"),e("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=r.exports}}]);