(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{741:function(e,o,v){"use strict";v.r(o);var _=v(55),s=Object(_.a)({},(function(){var e=this,o=e.$createElement,v=e._self._c||o;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"cookie-session-token-jwt"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cookie-session-token-jwt"}},[e._v("#")]),e._v(" Cookie,Session,Token,JWT")]),e._v(" "),v("blockquote",[v("p",[e._v("https://mp.weixin.qq.com/s/sF96Vgcp9FU--oeRlh4IdA")])]),e._v(" "),v("h1",{attrs:{id:"认证-authentication"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#认证-authentication"}},[e._v("#")]),e._v(" 认证（Authentication）")]),e._v(" "),v("p",[e._v("通俗地讲就是验证当前用户的身份")]),e._v(" "),v("p",[e._v("互联中的认证：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("用户名密码登录")])]),e._v(" "),v("li",[v("p",[e._v("邮箱发送登录链接")])]),e._v(" "),v("li",[v("p",[e._v("手机号接收验证码")]),e._v(" "),v("p",[e._v("只要你能收到邮箱/验证码，就默认你是账号的主人")])])]),e._v(" "),v("h1",{attrs:{id:"授权-authorization"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#授权-authorization"}},[e._v("#")]),e._v(" 授权(Authorization)")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("用户授予第三方应用访问该用户某些资源的权限")])]),e._v(" "),v("li",[v("p",[e._v("在安装手机应用的时候，APP会询问是否允许授予权限（访问相册、地理位置等权限）")])]),e._v(" "),v("li",[v("p",[e._v("你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）")])]),e._v(" "),v("li",[v("p",[e._v("实现授权的方式有："),v("code",[e._v("cookie")]),e._v("、"),v("code",[e._v("session")]),e._v("、"),v("code",[e._v("token")]),e._v("、"),v("code",[e._v("OAuth")])])])]),e._v(" "),v("h1",{attrs:{id:"cookie"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[e._v("#")]),e._v(" Cookie")]),e._v(" "),v("p",[e._v("HTTP是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息），每个请求都是完全独立的，\n服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），\n就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("cookie 存储在客户端")]),e._v(" "),v("p",[e._v("cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。")])]),e._v(" "),v("li",[v("p",[e._v("cookie 是不可跨域的")]),e._v(" "),v("p",[e._v("每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。")])])]),e._v(" "),v("h2",{attrs:{id:"session"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#session"}},[e._v("#")]),e._v(" session")]),e._v(" "),v("p",[e._v("什么 session ？")]),e._v(" "),v("p",[e._v("开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念")]),e._v(" "),v("p",[e._v("如何实现 session ？")]),e._v(" "),v("p",[e._v("实现 session 需要借助 cookie 和后端的一种存储机制来实现")]),e._v(" "),v("p",[e._v("上面所说的存储机制就是服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中")]),e._v(" "),v("h3",{attrs:{id:"session-认证流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#session-认证流程"}},[e._v("#")]),e._v(" session 认证流程")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session, 并生成一个"),v("code",[e._v("sessionId")])])]),e._v(" "),v("li",[v("p",[e._v("将"),v("code",[e._v("sessionId")]),e._v(" 保存 "),v("code",[e._v("cookie")]),e._v(" 中并返回给浏览器")])]),e._v(" "),v("li",[v("p",[e._v("当用户第二次访问服务器的时候，会自动携带设置的 "),v("code",[e._v("cookie")]),e._v(" 传给服务器")])]),e._v(" "),v("li",[v("p",[e._v("服务器接收到客户端传回的 "),v("code",[e._v("cookie")]),e._v(" 获取到其中的 "),v("code",[e._v("sessionId")]),e._v(",再根据 "),v("code",[e._v("SessionID")]),e._v(" 查找对应的 "),v("code",[e._v("Session")]),e._v(" 信息进行身份验证")])])]),e._v(" "),v("h3",{attrs:{id:"cookie-和-session-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cookie-和-session-的区别"}},[e._v("#")]),e._v(" Cookie 和 Session 的区别")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("session")]),e._v(" 存储在服务器端，"),v("code",[e._v("sessionId")]),e._v(" 会被存储到客户端的 "),v("code",[e._v("cookie")]),e._v(" 中，而 "),v("code",[e._v("cookie")]),e._v(" 存储在浏览器端")])]),e._v(" "),v("li",[v("p",[e._v("存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型")])]),e._v(" "),v("li",[v("p",[e._v("存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。")])])]),e._v(" "),v("h1",{attrs:{id:"token"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#token"}},[e._v("#")]),e._v(" Token")]),e._v(" "),v("p",[e._v("一般Token由以下元素组：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("uid:用户唯一的身份标识")])]),e._v(" "),v("li",[v("p",[e._v("time：当前时间的时间戳")])]),e._v(" "),v("li",[v("p",[e._v("sign:签名")])])]),e._v(" "),v("p",[e._v("Token的特点：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("服务端无状态化，可扩展性好")])]),e._v(" "),v("li",[v("p",[e._v("支持移动端设备")])]),e._v(" "),v("li",[v("p",[e._v("支持跨程序调用")])])]),e._v(" "),v("p",[e._v("token 的身份验证流程：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("客户端使用用户名跟密码请求登录")])]),e._v(" "),v("li",[v("p",[e._v("服务端收到请求，去验证用户名与密码")])]),e._v(" "),v("li",[v("p",[e._v("验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端")])]),e._v(" "),v("li",[v("p",[e._v("客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里")])]),e._v(" "),v("li",[v("p",[e._v("客户端每次向服务端请求资源的时候需要带着服务端签发的 token")])]),e._v(" "),v("li",[v("p",[e._v("服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据")])]),e._v(" "),v("li",[v("p",[e._v("服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据")])]),e._v(" "),v("li",[v("p",[e._v("基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库")])]),e._v(" "),v("li",[v("p",[e._v("token 完全由应用管理，所以它可以避开同源策略")])])]),e._v(" "),v("h1",{attrs:{id:"refresh-token"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#refresh-token"}},[e._v("#")]),e._v(" Refresh Token")]),e._v(" "),v("p",[e._v("另外一种 token——refresh token")]),e._v(" "),v("p",[e._v("refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。")])]),e._v(" "),v("li",[v("p",[e._v("Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。")])])]),e._v(" "),v("h1",{attrs:{id:"jwt"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jwt"}},[e._v("#")]),e._v(" JWT")]),e._v(" "),v("p",[e._v("JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。")]),e._v(" "),v("p",[e._v("JWT 认证流程：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT")])]),e._v(" "),v("li",[v("p",[e._v("客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）")])]),e._v(" "),v("li",[v("p",[e._v("当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样")]),e._v(" "),v("p",[e._v("Authorization: Bearer复制代码")])]),e._v(" "),v("li",[v("p",[e._v("服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为")])]),e._v(" "),v("li",[v("p",[e._v("因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库需要")])]),e._v(" "),v("li",[v("p",[e._v("因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制")])])]),e._v(" "),v("h1",{attrs:{id:"常见问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[e._v("#")]),e._v(" 常见问题")]),e._v(" "),v("p",[e._v("使用 cookie 时需要考虑的问题")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("因为存储在客户端，容易被客户端篡改，使用前需要验证合法性")])]),e._v(" "),v("li",[v("p",[e._v("不要存储敏感数据，比如用户密码，账户余额")])]),e._v(" "),v("li",[v("p",[e._v("使用 httpOnly 在一定程度上提高安全性")])]),e._v(" "),v("li",[v("p",[e._v("尽量减少 cookie 的体积，能存储的数据量不能超过 4kb")])]),e._v(" "),v("li",[v("p",[e._v("设置正确的 domain 和 path，减少数据传输")])]),e._v(" "),v("li",[v("p",[e._v("cookie 无法跨域")])]),e._v(" "),v("li",[v("p",[e._v("一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie")])]),e._v(" "),v("li",[v("p",[e._v("移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token")])])]),e._v(" "),v("p",[e._v("使用 session 时需要考虑的问题")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session")])]),e._v(" "),v("li",[v("p",[e._v("当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。")])]),e._v(" "),v("li",[v("p",[e._v("当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。")])]),e._v(" "),v("li",[v("p",[e._v("sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现")])]),e._v(" "),v("li",[v("p",[e._v("移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token")])])]),e._v(" "),v("p",[e._v("使用 token 时需要考虑的问题")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。")])]),e._v(" "),v("li",[v("p",[e._v("token 完全由应用管理，所以它可以避开同源策略")])]),e._v(" "),v("li",[v("p",[e._v("token 可以避免 CSRF 攻击(因为不需要 cookie 了)")])]),e._v(" "),v("li",[v("p",[e._v("移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token")])])]),e._v(" "),v("p",[e._v("使用 JWT 时需要考虑的问题")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）")])]),e._v(" "),v("li",[v("p",[e._v("JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。")])]),e._v(" "),v("li",[v("p",[e._v("JWT 不加密的情况下，不能将秘密数据写入 JWT。")])]),e._v(" "),v("li",[v("p",[e._v("JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。")])]),e._v(" "),v("li",[v("p",[e._v("JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。")])]),e._v(" "),v("li",[v("p",[e._v("JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。")])]),e._v(" "),v("li",[v("p",[e._v("JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。")])]),e._v(" "),v("li",[v("p",[e._v("为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。")])])])])}),[],!1,null,null,null);o.default=s.exports}}]);