(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{736:function(t,n,e){"use strict";e.r(n);var a=e(58),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"虚拟化长列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟化长列表"}},[t._v("#")]),t._v(" 虚拟化长列表")]),t._v(" "),e("p",[t._v("如果你的应用渲染了长列表（上百甚至上千的数据），我们推荐使用“虚拟滚动”技术。这项技术会在有限的时间内仅渲染有限的内容，并奇迹般地降低重新渲染组件消耗的时间，以及创建 DOM 节点的数量。")]),t._v(" "),e("p",[e("code",[t._v("react-window")]),t._v(" 和 "),e("code",[t._v("react-virtualized")]),t._v(" 是热门的虚拟滚动库。")]),t._v(" "),e("h2",{attrs:{id:"shouldcomponentupdate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate"}},[t._v("#")]),t._v(" shouldComponentUpdate")]),t._v(" "),e("p",[t._v("当一个组件的 props 或 state 变更，React 会将最新返回的元素与之前渲染的元素进行对比，以此决定是否有必要更新真实的 DOM。当它们不相同时，React 会更新该 DOM")]),t._v(" "),e("p",[t._v("即使 React 只更新改变了的 DOM 节点，重新渲染仍然花费了一些时间。在大部分情况下它并不是问题，不过如果它已经慢到让人注意了，\n你可以通过覆盖生命周期方法 "),e("code",[t._v("shouldComponentUpdate")]),t._v(" 来进行提速。该方法会在重新渲染前被触发。其默认实现总是返回 "),e("code",[t._v("true")]),t._v("，让 React 执行更新：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("shouldComponentUpdate(nextProps, nextState) {\n  return true;\n}\n")])])]),e("p",[t._v("如果你知道在什么情况下你的组件不需要更新，你可以在 "),e("code",[t._v("shouldComponentUpdate")]),t._v(" 中返回 "),e("code",[t._v("false")]),t._v(" 来跳过整个渲染过程")]),t._v(" "),e("p",[t._v("示例：")]),t._v(" "),e("p",[t._v("如果你的组件只有当 "),e("code",[t._v("props.color")]),t._v(" 或者 "),e("code",[t._v("state.count")]),t._v(" 的值改变才需要更新时，你可以使用 "),e("code",[t._v("shouldComponentUpdate")]),t._v(" 来进行检查")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class CounterButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {count: 1};\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (this.props.color !== nextProps.color) {\n      return true;\n    }\n    if (this.state.count !== nextState.count) {\n      return true;\n    }\n    return false;\n  }\n\n  render() {\n    return (\n      <button\n        color={this.props.color}\n        onClick={() => this.setState(state => ({count: state.count + 1}))}>\n        Count: {this.state.count}\n      </button>\n    );\n  }\n}\n")])])]),e("p",[t._v("在这段代码中，"),e("code",[t._v("shouldComponentUpdate")]),t._v(" 仅检查了 "),e("code",[t._v("props.color")]),t._v(" 或 "),e("code",[t._v("state.count")]),t._v(" 是否改变。\n如果这些值没有改变，那么这个组件不会更新。如果你的组件更复杂一些，你可以使用类似“浅比较”的模式来检查 "),e("code",[t._v("props")]),t._v(" 和 "),e("code",[t._v("state")]),t._v(" 中所有的字段，\n以此来决定是否组件需要更新。React 已经提供了一位好帮手来帮你实现这种常见的模式 - 你只要继承 "),e("code",[t._v("React.PureComponent")]),t._v(" 就行了。所以这段代码可以改成以下这种更简洁的形式")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class CounterButton extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {count: 1};\n  }\n\n  render() {\n    return (\n      <button\n        color={this.props.color}\n        onClick={() => this.setState(state => ({count: state.count + 1}))}>\n        Count: {this.state.count}\n      </button>\n    );\n  }\n}\n\n")])])]),e("p",[t._v("注意"),e("code",[t._v("React.PureComponent")]),t._v("只能进行数据浅比较，如果"),e("code",[t._v("props")]),t._v("或才"),e("code",[t._v("sate")]),t._v("是对象的话就无法监测其中的变化了")]),t._v(" "),e("h2",{attrs:{id:"更新dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更新dom"}},[t._v("#")]),t._v(" 更新DOM")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("尽可能不要改变DOM节构")])]),t._v(" "),e("li",[e("p",[t._v("添加 "),e("code",[t._v("key")]),t._v(" 属性， 提高diff 算法效率")])])]),t._v(" "),e("h2",{attrs:{id:"减少组件的重新渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#减少组件的重新渲染"}},[t._v("#")]),t._v(" 减少组件的重新渲染")]),t._v(" "),e("p",[t._v("对于相同的"),e("code",[t._v("props")]),t._v("或"),e("code",[t._v("state")]),t._v("更新，可以不做重新渲染处理，提高性能，相关的优化方式有：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("使用"),e("code",[t._v("shouldComponentUpdate")]),t._v("控制更新")])]),t._v(" "),e("li",[e("p",[t._v("对于像 "),e("code",[t._v("this")]),t._v(" 的类组件来说，React 提供了 "),e("code",[t._v("PureComponent")]),t._v(" 基类。扩展 "),e("code",[t._v("React.PureComponent")]),t._v(" 类的类组件被视为纯组件。")]),t._v(" "),e("ul",[e("li",[t._v("注意"),e("code",[t._v("PureComponent")]),t._v("使用的是浅层比较,如果如果属性包含有对象时，要注意")])])]),t._v(" "),e("li",[e("p",[t._v("对于函数组件，使用"),e("code",[t._v("React.memo")])])])]),t._v(" "),e("p",[t._v("如果先前的状态和 props 数据与下一个 props 或状态相同，则组件不会重新渲染。")]),t._v(" "),e("h2",{attrs:{id:"懒加载组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#懒加载组件"}},[t._v("#")]),t._v(" 懒加载组件")]),t._v(" "),e("p",[e("code",[t._v("Suspense")]),t._v("和"),e("code",[t._v("React.lazy")])]),t._v(" "),e("h2",{attrs:{id:"按需加载模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按需加载模块"}},[t._v("#")]),t._v(" 按需加载模块")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./math"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("math")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("math"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("26")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("h2",{attrs:{id:"使用-react-fragments-避免额外标记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-react-fragments-避免额外标记"}},[t._v("#")]),t._v(" 使用 React Fragments 避免额外标记")]),t._v(" "),e("h2",{attrs:{id:"不要使用内联函数定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不要使用内联函数定义"}},[t._v("#")]),t._v(" 不要使用内联函数定义")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import React from "react";\n\nexport default class InlineFunctionComponent extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Welcome Guest</h1>\n        <input type="button" onClick={(e) => { this.setState({inputValue: e.target.value}) }} value="Click For Inline Function" />\n      </div>\n    )\n  }\n}\n\n')])])]),e("p",[t._v("如果我们使用内联函数，则每次调用"),e("code",[t._v("render")]),t._v("函数时都会创建一个新的函数实例。")]),t._v(" "),e("p",[t._v("当 React 进行虚拟 DOM diffing 时，它每次都会找到一个新的函数实例；因此在渲染阶段它会会绑定新函数并将旧实例扔给垃圾回收。")]),t._v(" "),e("p",[t._v("因此直接绑定内联函数就需要额外做垃圾回收和绑定到 DOM 的新函数的工作。")]),t._v(" "),e("p",[t._v("优化后：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import React from "react";\n \nexport default class InlineFunctionComponent extends React.Component {\n  \n  setNewStateData = (event) => {\n    this.setState({\n      inputValue: e.target.value\n    })\n  }\n  \n  render() {\n    return (\n      <div>\n        <h1>Welcome Guest</h1>\n        <input type="button" onClick={this.setNewStateData} value="Click For Inline Function" />\n      </div>\n    )\n  }\n}\n\n')])])]),e("h2",{attrs:{id:"避免-componentwillmount-中的异步请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#避免-componentwillmount-中的异步请求"}},[t._v("#")]),t._v(" 避免 componentWillMount() 中的异步请求")]),t._v(" "),e("p",[t._v("原因：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("跟服务器端渲染（同构）有关系，如果在"),e("code",[t._v("componentWillMount")]),t._v("里面获取数据，"),e("code",[t._v("fetch data")]),t._v("会执行两次，一次在服务器端一次在客户端。在"),e("code",[t._v("componentDidMount")]),t._v("中可以解决这个问题")])]),t._v(" "),e("li",[e("p",[t._v("react16.0以后，"),e("code",[t._v("componentWillMount")]),t._v("可能会被执行多次")])])]),t._v(" "),e("h2",{attrs:{id:"在-constructor-的早期绑定函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在-constructor-的早期绑定函数"}},[t._v("#")]),t._v(" 在 Constructor 的早期绑定函数")]),t._v(" "),e("p",[t._v("当我们在 React 中创建函数时，我们需要使用 bind 关键字将函数绑定到当前上下文。")]),t._v(" "),e("p",[t._v("绑定可以在构造函数中完成，也可以在我们将函数绑定到 DOM 元素的位置上完成。")]),t._v(" "),e("p",[t._v("两者之间似乎没有太大差异，但性能表现是不一样的。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import React from "react";\n\nexport default class DelayedBinding extends React.Component {\n  constructor() {\n    this.state = {\n      name: "Mayank"\n    }\n  }\n  \n  handleButtonClick() {\n    alert("Button Clicked: " + this.state.name)\n  }\n  \n  render() {\n    return (\n      <>\n        <input type="button" value="Click" onClick={this.handleButtonClick.bind(this)} />\n      </>\n    )\n  }\n}\n\n')])])]),e("p",[t._v("在上面的代码中，我们在 render 函数的绑定期间将函数绑定到按钮上。")]),t._v(" "),e("p",[t._v("上面代码的问题在于，每次调用 render 函数时都会创建并使用绑定到当前上下文的新函数，但在每次渲染时使用已存在的函数效率更高。优化方案如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import React from "react";\n\nexport default class DelayedBinding extends React.Component {\n  constructor() {\n    this.state = {\n      name: "Mayank"\n    }\n    this.handleButtonClick = this.handleButtonClick.bind(this)\n  }\n  \n  handleButtonClick() {\n    alert("Button Clicked: " + this.state.name)\n  }\n  \n  render() {\n    return (\n      <>\n        <input type="button" value="Click" onClick={this.handleButtonClick} />\n      </>\n    )\n  }\n}\n\n')])])]),e("h2",{attrs:{id:"箭头函数与构造函数中的绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数与构造函数中的绑定"}},[t._v("#")]),t._v(" 箭头函数与构造函数中的绑定")]),t._v(" "),e("p",[t._v("处理类时的标准做法就是使用箭头函数。使用箭头函数时会保留执行的上下文。")]),t._v(" "),e("p",[t._v("我们调用它时不需要将函数绑定到上下文")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import React from "react";\n\nexport default class DelayedBinding extends React.Component {\n  constructor() {\n    this.state = {\n      name: "Mayank"\n    }\n  }\n  \n  handleButtonClick = () => {\n    alert("Button Clicked: " + this.state.name)\n  }\n  \n  render() {\n    return (\n      <>\n        <input type="button" value="Click" onClick={this.handleButtonClick} />\n      </>\n    )\n  }\n}\n\n')])])]),e("p",[t._v("箭头函数好处多多，但也有缺点。")]),t._v(" "),e("p",[t._v("当我们添加箭头函数时，该函数被添加为对象实例，而不是类的原型属性。这意味着如果我们多次复用组件，那么在组件外创建的每个对象中都会有这些函数的多个实例。")]),t._v(" "),e("p",[t._v("每个组件都会有这些函数的一份实例，影响了可复用性。此外因为它是对象属性而不是原型属性，所以这些函数在继承链中不可用。")]),t._v(" "),e("p",[t._v("因此箭头函数确实有其缺点。实现这些函数的最佳方法是在构造函数中绑定函数，如上所述。")]),t._v(" "),e("h2",{attrs:{id:"避免使用内联样式属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#避免使用内联样式属性"}},[t._v("#")]),t._v(" 避免使用内联样式属性")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import React from "react";\n\nexport default class InlineStyledComponents extends React.Component {\n  render() {\n    return (\n      <>\n        <b style={{"backgroundColor": "blue"}}>Welcome to Sample Page</b>\n      </>\n    )\n  }\n}\n\n')])])]),e("p",[t._v("在上面创建的组件中，我们将内联样式附加到组件。添加的内联样式是 JavaScript 对象而不是样式标记。")]),t._v(" "),e("p",[t._v("样式 backgroundColor 需要转换为等效的 CSS 样式属性，然后才应用样式。这样就需要额外的脚本处理和 JS 执行工作。")]),t._v(" "),e("p",[t._v("更好的办法是将 CSS 文件导入组件")]),t._v(" "),e("h2",{attrs:{id:"为组件创建错误边界"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为组件创建错误边界"}},[t._v("#")]),t._v(" 为组件创建错误边界")]),t._v(" "),e("p",[t._v("错误边界是一个 React 组件，可以捕获子组件中的 JavaScript 错误。我们可以包含错误、记录错误消息，并为 UI 组件故障提供回退机制")]),t._v(" "),e("p",[t._v("错误边界涉及一个高阶组件，包含以下方法："),e("code",[t._v("static getDerivedStateFromError()")]),t._v(" 和 "),e("code",[t._v("componentDidCatch()")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"使用唯一键迭代"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用唯一键迭代"}},[t._v("#")]),t._v(" 使用唯一键迭代")]),t._v(" "),e("p",[t._v("当我们需要渲染项目列表时应该为项目添加一个键")]),t._v(" "),e("h2",{attrs:{id:"事件节流和防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件节流和防抖"}},[t._v("#")]),t._v(" 事件节流和防抖")]),t._v(" "),e("p",[t._v("这是个通用优化方案了")]),t._v(" "),e("h2",{attrs:{id:"使用-cdn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-cdn"}},[t._v("#")]),t._v(" 使用 CDN")]),t._v(" "),e("h2",{attrs:{id:"用-css-动画代替-javascript-动画"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用-css-动画代替-javascript-动画"}},[t._v("#")]),t._v(" 用 CSS 动画代替 JavaScript 动画")]),t._v(" "),e("h2",{attrs:{id:"在-web-服务器上启用-gzip-压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在-web-服务器上启用-gzip-压缩"}},[t._v("#")]),t._v(" 在 Web 服务器上启用 gzip 压缩")]),t._v(" "),e("h2",{attrs:{id:"react-组件的服务端渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-组件的服务端渲染"}},[t._v("#")]),t._v(" React 组件的服务端渲染")])])}),[],!1,null,null,null);n.default=s.exports}}]);