(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{621:function(e,a,r){"use strict";r.r(a);var s=r(53),o=Object(s.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"loader"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#loader"}},[e._v("#")]),e._v(" Loader")]),e._v(" "),r("p",[e._v("Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，\n对其他类型的资源进行转译的预处理工作。")]),e._v(" "),r("p",[e._v("Loader 在 "),r("code",[e._v("module.rules")]),e._v(" 中配置，作为模块的解析规则，类型为数组。每一项都是一个 "),r("code",[e._v("Object")]),e._v("，\n内部包含了 "),r("code",[e._v("test")]),e._v("(类型文件)、"),r("code",[e._v("loader")]),e._v("、"),r("code",[e._v("options")]),e._v(" (参数)等属性。")]),e._v(" "),r("p",[e._v("Loader就像一个翻译员，能将源文件经过转换成新的结果，")]),e._v(" "),r("p",[e._v("以处理SCSS文件为例：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("先将SCSS源码交给sass-loader处理，转换成CSS")])]),e._v(" "),r("li",[r("p",[e._v("sass-loader转换的css结果再交给css-loader处理，找出CSS中依赖的资源，压缩CSS等")])]),e._v(" "),r("li",[r("p",[e._v("将css-loader输出的CSS提交给style-loader处理，转换成通过脚本加载的JavaScript代码")])])]),e._v(" "),r("p",[e._v("可以看出，以上处理过程需要有顺序得执行，先sass-loader，再css-loader，再style-loader。以上处理的Webpack的相关配置如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v(" module.export = {\n    module: {\n      rules: [\n        {\n          // 增加对SCSS文件的支持\n          test: /\\.scss/,\n          // SCSS文件的处理顺序为先sass-loader，再css-loader，再style-loader\n          use: [\n            'style-loader',\n            {\n              loader: 'css-loader',\n              options: {\n                minimize: true\n              },\n            },\n            'sass-loader'\n          ],\n\n        }\n      ]\n    }\n  }\n")])])]),r("h2",{attrs:{id:"loader的职责特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#loader的职责特点"}},[e._v("#")]),e._v(" Loader的职责特点")]),e._v(" "),r("p",[e._v("一个Loader的职责是单一的，只需要完成一次转换。如果一个源文件需要经历多步转换那么就通过多个Loader去转换。")]),e._v(" "),r("h2",{attrs:{id:"loader基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#loader基础"}},[e._v("#")]),e._v(" Loader基础")]),e._v(" "),r("p",[e._v("Webpack是运行在Node.js上的，所以一个Loader其实就是一个Node模块，这个模块需要导出一个函数，这个导出的函数的工作就是获得处理前的内容，\n对原内容执行处理后，返回处理后的内容。")]),e._v(" "),r("p",[e._v("一个最简单的Loader的源码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("  module.exports = function (source) {\n    // source为compiler传递给Loader的一个文件的原内容\n    // 该函数需要返回处理后的内容，这里为了简单起见，直接将原内容返回了，相当于该Loader没有做任何转换\n    return source \n  }\n")])])]),r("p",[e._v("由于Loader是运行在Node.js上的，所以可以调用任意的Node.js自带的API")]),e._v(" "),r("h2",{attrs:{id:"loader进阶"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#loader进阶"}},[e._v("#")]),e._v(" Loader进阶")]),e._v(" "),r("h3",{attrs:{id:"获得loader的options"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#获得loader的options"}},[e._v("#")]),e._v(" 获得Loader的options")]),e._v(" "),r("p",[e._v("在最上面处理SCSS文件的Webpack配置中，将options参数传递给了css-loader，以控制css-loader。如何在自己编写的Loader中获取用户传入的options呢？需要这样做：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v(" const loaderUtils = require('loader-utils')\n  module.exports = function (source) {\n    // source为compiler传递给Loader的一个文件的原内容\n    // 该函数需要返回处理后的内容，这里为了简单起见，直接将原内容返回了，相当于该Loader没有做任何转换\n    const options = loaderUtils.getOptions(this)\n    return source\n  }\n")])])]),r("h3",{attrs:{id:"返回其它结果"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回其它结果"}},[e._v("#")]),e._v(" 返回其它结果")]),e._v(" "),r("p",[e._v("上面的Loader都只是返回了原内容转换的内容，但是某些场景下还需要返回除了内容之后的东西。")]),e._v(" "),r("p",[e._v("以用label-loader转换ES6代码为例，它还需要输出转换后的ES5代码对应的Source Map，以方便调试源码。为了将Source Map也一起随着ES5代码返回给Webpack，还可以这样写：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const loaderUtils = require('loader-utils')\n  module.exports = function (source) {\n    // 通过this.callback告诉Webpack返回的结果 \n    this.callback(null, source, sourceMaps)\n    // 当我们使用this.callback返回内容时，该Loader必须返回undefined,\n    // 当让Webpack知道该Loader返回的结果 在this.callback中，而不是return中\n    return\n  }\n")])])]),r("p",[e._v("其中的"),r("code",[e._v("this.csllback")]),e._v("是Webpack向Loader注入的API，以方便Loader和Webpack之间通信。"),r("code",[e._v("this.callback")]),e._v("的详细使用方法如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v(" this.callback(\n    // 当无法转换原内容时，为Webpack返回一个Error\n    err: Error | null,\n    // 原内容转换后的内容\n    content: string | Buffer,\n    // 用于通过转换后的内容得出原内容的Source Map，以方便调试\n    sourceMap?: SourceMap,\n    // 如果本次转换为原内容生成了AST语法树，则可以将这个AST返回，\n    // 以方便之后需要AST的Loader利用该AST，避免重复生成AST，提升性能\n    abstractSyntaxTree?: AST\n  )\n")])])]),r("p",[e._v("Source Map的生成很耗时，通常在开发环境下才会生成Source Map，在其它环境下不用生成，以加快构建。因此，Webpack为Loader提供了"),r("code",[e._v("this.sourceMap")]),e._v("API去告诉Loader在当前构建环境下用户是否需要Source Map")]),e._v(" "),r("h2",{attrs:{id:"同步与异步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步与异步"}},[e._v("#")]),e._v(" 同步与异步")]),e._v(" "),r("p",[e._v("Loader也有同步与异步之分，上面介绍的Loader都是同步的Loader，因为它们的转换流程都是同步的，转换完后再返回结果 。但在某些场景下转换的步骤只能是迅步完成的，例如我们需要通过网络请求才能得出结果，如果采用同样的方式，则网络请求会阻塞整个构建 ，导致构建非常缓慢。")]),e._v(" "),r("p",[e._v("如果是异步转换，则我们可以这样做：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("  module.exoprts = function (source) {\n    var callback = this.async()\n    someAsyncOperation(source, function (err, result, sourceMaps, ast) {\n      // 通过callback返回异步执行的结果 \n      callback(err, result, sourceMaps, ast)\n      \n    })\n  }\n")])])]),r("h2",{attrs:{id:"处理二进制数据"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#处理二进制数据"}},[e._v("#")]),e._v(" 处理二进制数据")]),e._v(" "),r("p",[e._v("在默认情况下，Webpack传给Loader的原内容都是UTF-8格式编码的字符串。但在某些场景下Loader不会处理文本文件，而会处理二进制文件如file-loader，这时就需要Webapck为Loader传入二进制格式的数据。为些，我们需要这编写Loader：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("  module.exoprts = function (source) {\n    // 在exports.raw === true时，Webpack传给Loader的source是Buffer类型的\n    source instanceof Buffer === true\n    // Loader返回的类型也可以是Buffer类型的\n    // 在exports.raw !== true时，Loader也可以返回Buffer类型的结果 \n    return source\n  }\n  module.exports.raw = true\n")])])]),r("p",[e._v("在以上代码最关键的代码是最后一行"),r("code",[e._v("module.exports.raw = true")]),e._v("，若没有该代码，则Loader只能拿到字符串。")]),e._v(" "),r("h2",{attrs:{id:"缓存加速"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存加速"}},[e._v("#")]),e._v(" 缓存加速")]),e._v(" "),r("p",[e._v("在某些情况下，有些转换操作需要大量的计算，非常耗时，如果每次构建都重新执行重复的转换操作，则构建操作会变得非常缓慢。为此，Webpack会默认缓存所有Loader的处理结果，也就是需要被处理的文件或者其依赖的文件没有发生变化时，是不会重新调用对应的Loader去执行转换操作的。")]),e._v(" "),r("p",[e._v("如果我们不想让Webpack缓存该Loader的处理结果，则可以这样：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v(" module.exoprts = function (source) {\n   // 关闭该Loader的缓存功能\n    this.cacheable(false)\n    return source\n  }\n  module.exports.raw = true\n")])])]),r("h2",{attrs:{id:"其他loader-api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#其他loader-api"}},[e._v("#")]),e._v(" 其他Loader API")]),e._v(" "),r("p",[e._v("除了以上提到的在Loader中能调用的Webpack API，还存在以下常用的API。")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("this.context：当前处理的文件所在目录，假如当前Loader处理的文件"),r("code",[e._v("/src/main.js")]),e._v("，则"),r("code",[e._v("this.context")]),e._v("等于"),r("code",[e._v("/src")])])]),e._v(" "),r("li",[r("p",[e._v("this.resource：当前处理的文件的完整请求路径，包括querystring，例如"),r("code",[e._v("/src/main.js?name=1")])])]),e._v(" "),r("li",[r("p",[e._v("this.resourcePath：当前处理的文件的路径，例如"),r("code",[e._v("/src/main.js")])])]),e._v(" "),r("li",[r("p",[e._v("this.resourcePath：当前处理的文件的querystring")])]),e._v(" "),r("li",[r("p",[e._v("this.target：等于Webpack配置中的Target")])]),e._v(" "),r("li",[r("p",[e._v("this.loadModule：当Loader在处理一个文件时，如果依赖其他文件的处理结果才能得到当前文件的结果，就可以通过"),r("code",[e._v("this.loadModule(request: string, callback:function(err,source, sourceMap, module))")]),e._v("去获取require对应的文件的处理结果")])]),e._v(" "),r("li",[r("p",[e._v("this.resolve：像require语句一样获得指定文件的完整路径，使用方法为"),r("code",[e._v("resolve(context:string, request:string,callback:function(err, result:string))")])])]),e._v(" "),r("li",[r("p",[e._v("this.addDependency：为当前处理的文件添加其依赖的文件，以便其依赖的文件发生变化 时，重新调用Loader处理该文件。使用方法为"),r("code",[e._v("addDependency(file: string)")])])]),e._v(" "),r("li",[r("p",[e._v("this.addContextDependency：和addDependency类似，但addContextDependency是将整个目录加入当前正在处理的文件的依赖中。使用方法为"),r("code",[e._v("addContextDependency(directory: string)")])])]),e._v(" "),r("li",[r("p",[e._v("this.clearDependencies：清除当前正在处理文件的所有依赖，使用方法为"),r("code",[e._v("clearDepentdencies()")])])]),e._v(" "),r("li",[r("p",[e._v("this.emitFile：输出一个文件，使用方法为"),r("code",[e._v("emitFile(name: string, content: Buffer|string, sourceMap:{})")])])])]),e._v(" "),r("h2",{attrs:{id:"加载本地loader"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#加载本地loader"}},[e._v("#")]),e._v(" 加载本地Loader")]),e._v(" "),r("p",[e._v("正常在Webpack使用的Loader都是从npm上安装的，如果直接使用本地的Loader呢？")]),e._v(" "),r("ol",[r("li",[e._v("Npm link")])]),e._v(" "),r("p",[e._v("Npm link专门用于开发和高度本地的Npm模块，能做到在不发布模块的情况下，将本地的一个正在开发的模块的源码链接到项目的"),r("code",[e._v("node_modules")]),e._v("目录下，让项目可以直接使用本地的Npm模块。由于是通过软链接的方式实现的，编辑了本地的Npm模块的代码，所以在项目中也能使用到编辑后的代码。")]),e._v(" "),r("p",[e._v("完成Npm link的步骤如下：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("确保在开发的Npm模块（也就是正在开发的Loader）的package.json已经正确配置好")])]),e._v(" "),r("li",[r("p",[e._v("在本地的Npm模块根目录执行npm link，将本地模块注册到全局")])]),e._v(" "),r("li",[r("p",[e._v("在项目根目录下执行"),r("code",[e._v("npm link loader-name")]),e._v("，将第2步注册到全局的本地Npm模块链到项目的"),r("code",[e._v("node_modules")]),e._v("下，其中的loader-name是指第1步的package.json文件中配置的模块名称")])])]),e._v(" "),r("p",[e._v("链接Loader到项目后我们就可以像使用一个真正的Npm模块一样使用本地的Loader了")]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[e._v("ResolveLoader")])]),e._v(" "),r("p",[e._v("ResolveLoader用于配置Webpack如何寻找Loader，它在默认情况下只会"),r("code",[e._v("node_modules")]),e._v("目录下寻找。为了让Webpack加载放在本地项目的Loader，需要修改"),r("code",[e._v("resolveLoader.modules")])]),e._v(" "),r("p",[e._v("假如本地项目中的Loader在项目目录的"),r("code",[e._v("./laoders/loader-name")]),e._v("下，则需要如下配置：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v(" module.exports = {\n    resolveLoader: {\n      // 去哪些目录下寻找Loader，有先后顺序之分\n      modules: ['node_modules', './loaders']\n    }\n  }\n")])])]),r("h2",{attrs:{id:"实战"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实战"}},[e._v("#")]),e._v(" 实战")]),e._v(" "),r("p",[e._v("编写一个comment-require-loader的Loader，作用是该注释语法：")]),e._v(" "),r("p",[r("code",[e._v("// @reuiqre '../style/index.css'")])]),e._v(" "),r("p",[e._v("转换成：")]),e._v(" "),r("p",[r("code",[e._v("require('../style/index.css')")])]),e._v(" "),r("p",[e._v("该Loader的使用场景是针对Fis3编写的JavaScript，这些JavaScript中通过注释的方式依赖的CSS文件")]),e._v(" "),r("p",[e._v("该Loader的使用方式如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("module.exports = {\n    module: {\n      loaders: [\n        {\n          test: /\\.js$/,\n          loaders: ['common-require-loader'],\n          include: [path.resolve(__dirname, 'node_modules/imui')]\n        }\n      ]\n    }\n  }\n")])])]),r("p",[e._v("该Loader的实现代码：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("  function replace(source) {\n    return source.replace(/(\\/\\/ *@require) + (('|\").+('|\")).*/, 'require($2);')\n  }\n  module.exports = function (content) {\n    return replace(content)\n  }\n")])])]),r("h1",{attrs:{id:"loader执行顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#loader执行顺序"}},[e._v("#")]),e._v(" loader执行顺序")]),e._v(" "),r("p",[e._v("正常情况下 loader 的执行顺序是倒序的")]),e._v(" "),r("p",[e._v("但可以通过enforce属性去改变执行顺序：")]),e._v(" "),r("ul",[r("li",[r("p",[r("code",[e._v("enforce:'pre'")]),e._v(" 前置 权重最高")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("enforce:'normal'")]),e._v(" 不变 权重第二")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("enforce:'inline'")]),e._v(" 行内 权重第三")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("enforce:'post'")]),e._v(" 后置 权重第四")])])])])}),[],!1,null,null,null);a.default=o.exports}}]);