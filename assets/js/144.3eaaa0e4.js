(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{698:function(t,s,a){"use strict";a.r(s);var e=a(55),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"时间切片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间切片"}},[t._v("#")]),t._v(" 时间切片")]),t._v(" "),a("p",[t._v("最早是从Lin Clark分享的经典Fiber演讲中了解到的时间切片。时间切片指的是一种将多个粒度小的任务放入一个个时间切片中执行的一种方法")]),t._v(" "),a("p",[a("strong",[t._v("时间切片的作用")])]),t._v(" "),a("p",[t._v("在刚执行完一个时间切片准备执行下一个时间切片前，React能够：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("判断是否有用户界面交互事件和其他需要执行的代码，比如点击事件，有的话则执行该事件")])]),t._v(" "),a("li",[a("p",[t._v("判断是否有优先级更高的任务需要执行，如果有，则中断当前任务，执行更高的优先级任务。也就是利用时间前片来实现高优先级任务插队。")])])]),t._v(" "),a("p",[t._v("即时间切片有两个作用：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在执行任务过程中，不阻塞用户与页面交互，立即响应交互事件和需要执行的代码")])]),t._v(" "),a("li",[a("p",[t._v("实现高优先级插队")])])]),t._v(" "),a("h2",{attrs:{id:"react对时间切片的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react对时间切片的实现"}},[t._v("#")]),t._v(" React对时间切片的实现")]),t._v(" "),a("p",[t._v("首先在这里引入当前React版本中的一段注释说明：")]),t._v(" "),a("blockquote",[a("p",[t._v("// Scheduler periodically yields in case there is other work on the main"),a("br"),t._v("\n// thread, like user events. By default, it yields multiple times per frame."),a("br"),t._v("\n// It does not attempt to align with frame boundaries, since most tasks don't"),a("br"),t._v("\n// need to be frame aligned; for those that do, use requestAnimationFrame."),a("br"),t._v("\nlet yieldInterval = 5;")])]),t._v(" "),a("p",[a("code",[t._v("let yieldInterval = 5")]),t._v("，表示时间切片周期, 默认是 "),a("code",[t._v("5ms")]),t._v(" (如果一个 task 运行超过该周期, 下一个 task 执行之前, 会把控制权归还浏览器)"),a("br"),t._v("\n注释中说一个帧中会有多个时间切片（显而易见，一帧~=16.67ms，包含3个时间切片还多），切片时间不会与帧对齐，如果要与帧对齐，则使用 "),a("code",[t._v("requestAnimationFrame")])]),t._v(" "),a("h3",{attrs:{id:"message-channel和fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#message-channel和fiber"}},[t._v("#")]),t._v(" Message Channel和Fiber")]),t._v(" "),a("p",[t._v("了解时间切片实现方法前需掌握的知识点:Message Channel 和 Fiber")]),t._v(" "),a("p",[a("strong",[t._v("Message Channel")])]),t._v(" "),a("p",[t._v("浏览器提供的一种数据通信接口，可用来实现订阅发布。其特点是其两个端口属性支持双向通信和异步发布事件")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" channel "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MessageChannel")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" port1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" channel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("port1\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" port2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" channel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("port2\n\nport1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onmessage")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nport2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("postMessage")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'from port2'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'after port2 postMessage'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nport2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onmessage")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nport1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("postMessage")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'from port1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'after port1 postMessage'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 控制台输出: ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// after port2 postMessage")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// after port1 postMessage")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// from port2")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// from port1")]),t._v("\n")])])]),a("p",[a("strong",[t._v("Fiber")])]),t._v(" "),a("p",[t._v("Fiber是一个的节点对象，React使用链表的形式将所有Fiber节点连接，形成链表树，即虚拟DOM树")]),t._v(" "),a("p",[t._v("当有更新出现，React会生成一个工作中的 Fiber树，并对工作中 Fiber树 上每一个 Fiber节点 进行计算和 "),a("code",[t._v("diff")]),t._v("，完成计算工作（React称之为渲染步骤）之后，再更新DOM（提交步骤）")]),t._v(" "),a("h3",{attrs:{id:"具体实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具体实现"}},[t._v("#")]),t._v(" 具体实现")]),t._v(" "),a("p",[t._v("首先 React 会默认有许多微小任务，即所有的工作中 fiber节点")]),t._v(" "),a("p",[t._v("在执行调度工作循环和计算工作循环时，执行每一个工作中Fiber。但是，有一个条件是每隔 "),a("code",[t._v("5毫秒")]),t._v("，会跳出工作循环，运行一次异步的 "),a("code",[t._v("MessageChannel")]),t._v(" 的 "),a("code",[t._v("port.postMessage(...)")]),t._v(" 方法，检查是否存在事件响应、更高优先级任务或其他代码需要执行，如果有则执行，如果没有则重新创建工作循环，执行剩下的工作中Fiber")])])}),[],!1,null,null,null);s.default=n.exports}}]);