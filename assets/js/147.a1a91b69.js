(window.webpackJsonp=window.webpackJsonp||[]).push([[147],{730:function(v,e,_){"use strict";_.r(e);var t=_(58),o=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"vsvue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vsvue"}},[v._v("#")]),v._v(" vsVue")]),v._v(" "),_("h2",{attrs:{id:"模板渲染方式的不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模板渲染方式的不同"}},[v._v("#")]),v._v(" 模板渲染方式的不同")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Vue 模板的编写类似原生的 HTML 语法，一个 Vue组件通过模板+JavaScript+CSS的组合模式呈现（Vue更加注重web开发者的习惯），然后通过使用 Vue 内置很多 API 进行开发，如一些"),_("code",[v._v("v-model")]),v._v("，"),_("code",[v._v("v-if")]),v._v(","),_("code",[v._v("v-for")]),v._v(","),_("code",[v._v("watch")]),v._v(","),_("code",[v._v("computed")]),v._v(" 等等")])]),v._v(" "),_("li",[_("p",[v._v("React 的特色在于函数式编程的理念，是通过JSX渲染模板，使用JS来创建页面模板，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生")]),v._v(" "),_("p",[v._v("react 中我们 "),_("code",[v._v("import")]),v._v(" 的组件在 "),_("code",[v._v("render")]),v._v(" 中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 "),_("code",[v._v("this")]),v._v(" 上进行一次中转，所以我们 "),_("code",[v._v("import")]),v._v(" 一个组件完了之后，还需要在 "),_("code",[v._v("components")]),v._v(" 中再声明下，这样显然是很奇怪但又不得不这样的做法")])])]),v._v(" "),_("h2",{attrs:{id:"更新机制的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#更新机制的区别"}},[v._v("#")]),v._v(" 更新机制的区别")]),v._v(" "),_("p",[_("strong",[v._v("获取数据更新的手段和更新的粒度不一样")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Vue 通过依赖收集，当数据更新时， Vue 明确地知道是哪些数据更新了，每个组件都有自己的渲染 "),_("code",[v._v("watcher")]),v._v(" ，掌管当前组件的视图更新，所以可以精确地更新对应的组件，所以更新的粒度是组件级别的，所以为了避免不必要的渲染需要通过 "),_("code",[v._v("shouldComponentUpdate")]),v._v(" 这个生命周期方法可以进行控制")])]),v._v(" "),_("li",[_("p",[v._v("React 会递归地把所有的子组件 "),_("code",[v._v("re-render")]),v._v(" 一下，不管是不是更新的数据，此时，都是新的。然后通过 "),_("code",[v._v("diff")]),v._v(" 算法 来决定更新哪部分的视图。所以，React 的更新粒度是一个整体")])])]),v._v(" "),_("p",[_("strong",[v._v("对更新数据是否需要渲染页面的处理不一样")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("只有依赖收集的数据发生更新，Vue 才会去重新渲染页面")])]),v._v(" "),_("li",[_("p",[v._v("只要数据有更新（ "),_("code",[v._v("setState")]),v._v("，"),_("code",[v._v("useState")]),v._v(" 等手段触发更新），都会去重新渲染页面（可以使用 "),_("code",[v._v("shouldComponentUpdate/ PureComponent")]),v._v(" 改善）")])])]),v._v(" "),_("h2",{attrs:{id:"hoc和mixins"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hoc和mixins"}},[v._v("#")]),v._v(" HoC和mixins")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Vue组合不同功能的方式是通过mixin")])]),v._v(" "),_("li",[_("p",[v._v("React组合不同功能的方式是通过HoC(高阶组件）")])])]),v._v(" "),_("h2",{attrs:{id:"diff算法区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#diff算法区别"}},[v._v("#")]),v._v(" diff算法区别")]),v._v(" "),_("p",[v._v("vue和react的diff算法，都是忽略跨级比较，只做同级比较")]),v._v(" "),_("h2",{attrs:{id:"vuex和redux的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vuex和redux的区别"}},[v._v("#")]),v._v(" Vuex和Redux的区别")]),v._v(" "),_("p",[_("strong",[v._v("Redux 的核心概念")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("action： action默认是同步的 ，或借助中间件实现异步操作，"),_("code",[v._v("action")]),v._v(" 不会改变 "),_("code",[v._v("store")]),v._v("，只是描述了怎么改变 "),_("code",[v._v("store")])])]),v._v(" "),_("li",[_("p",[v._v("reducer: 纯函数，根据 "),_("code",[v._v("action")]),v._v(" 更新出新的 store")])]),v._v(" "),_("li",[_("p",[v._v("store：单一数据源")])])]),v._v(" "),_("h3",{attrs:{id:"vuex-的核心概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vuex-的核心概念"}},[v._v("#")]),v._v(" Vuex 的核心概念")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("mutation：用于同步操作直接修改 state")])]),v._v(" "),_("li",[_("p",[v._v("action：可用于异步操作，再通过提交 "),_("code",[v._v("mutation")]),v._v(" 进行 "),_("code",[v._v("store")]),v._v(" 的更新")])]),v._v(" "),_("li",[_("p",[v._v("store：单一数据源")])])]),v._v(" "),_("p",[_("strong",[v._v("使用区别")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("在 Vuex 中，"),_("code",[v._v("$store")]),v._v(" 被直接注入到了组件实例中，因此可以比较灵活的使用：使用 "),_("code",[v._v("dispatch")]),v._v("、"),_("code",[v._v("commit")]),v._v(" 提交更新，通过 "),_("code",[v._v("mapState")]),v._v(" 或者直接通过 "),_("code",[v._v("this.$store")]),v._v(" 来读取数据")])]),v._v(" "),_("li",[_("p",[v._v("在 Redux 中，通常需要借助 "),_("code",[v._v("connect")]),v._v(" 来获取 Action 生成 "),_("code",[v._v("Action Creators")]),v._v(" ， 同时将 "),_("code",[v._v("Action Creators")]),v._v(" 传递给子组件，所以子组件不需要直接使用 "),_("code",[v._v("dispatch")]),v._v(" 方法，而是直接调用该方法即可触发 "),_("code",[v._v("Action")])])])]),v._v(" "),_("p",[v._v("另外Vuex更加灵活一些，组件中既可以 "),_("code",[v._v("dispatch action")]),v._v("，也可以 "),_("code",[v._v("commit updates")]),v._v("，而Redux中只能进行 "),_("code",[v._v("dispatch")]),v._v("，不能直接调用 "),_("code",[v._v("reducer")]),v._v("进行修改。")]),v._v(" "),_("p",[_("strong",[v._v("实现原理")])]),v._v(" "),_("p",[v._v("Redux使用的是不可变数据，而Vuex的数据是可变的")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Redux每次都是用 "),_("code",[v._v("新state")]),v._v(" 替换 "),_("code",[v._v("旧state")]),v._v(" ，Redux在检测数据变化的时候，是通过diff的方式比较差异的")])]),v._v(" "),_("li",[_("p",[v._v("Vuex是对需要修改的属性进行直接修改，而Vuex其实和Vue的原理一样，是通过 "),_("code",[v._v("getter/setter")]),v._v(" 来比较的")])])]),v._v(" "),_("h3",{attrs:{id:"处理异步操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#处理异步操作"}},[v._v("#")]),v._v(" 处理异步操作")]),v._v(" "),_("p",[v._v("Redux 得益于 中间件机制，利用 "),_("code",[v._v("redux-thunk")]),v._v("， "),_("code",[v._v("redux-thunk")]),v._v(" 可以 "),_("code",[v._v("dispatch")]),v._v(" 函数，这个函数用于生成 "),_("code",[v._v("action")]),v._v("，所以在这个函数里面我们可以进行异步操作，等异步的结果出来后再放在 "),_("code",[v._v("action")]),v._v(" 里面将这个 "),_("code",[v._v("action")]),v._v(" 用 "),_("code",[v._v("dispatch")]),v._v(" 分发出去, 而这个函数被叫做 “action creator”")]),v._v(" "),_("p",[v._v("而 Vuex 是用 "),_("code",[v._v("mutation")]),v._v(" 来对应 Redux 的 "),_("code",[v._v("action")]),v._v("，另外 Vuex 又创造了一个 "),_("code",[v._v("action")]),v._v(" 来提交 "),_("code",[v._v("mutation")]),v._v(" 并通过异步提交 "),_("code",[v._v("mutation")]),v._v(" 来实现异步操作结果能够到达 "),_("code",[v._v("state")])]),v._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue 更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用 React，小型项目用 Vue 的感觉")])])}),[],!1,null,null,null);e.default=o.exports}}]);