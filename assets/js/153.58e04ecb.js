(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{746:function(e,t,a){"use strict";a.r(t);var r=a(58),c=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"react-ssr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-ssr"}},[e._v("#")]),e._v(" React SSR")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://img1.3s78.com/codercto/bac37e796d88613610eb0188e0d46ae0",alt:""}})]),e._v(" "),a("h2",{attrs:{id:"react-同构的关键要素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-同构的关键要素"}},[e._v("#")]),e._v(" React 同构的关键要素")]),e._v(" "),a("p",[e._v("###　DOM 的一致性")]),e._v(" "),a("p",[e._v("前后端相同的 Component , 将输出一致地 DOM 结构")]),e._v(" "),a("p",[e._v("完善的 Component 属性及生命周期与客户端的 render 时机是 React 同构的关键")]),e._v(" "),a("p",[e._v("React 的虚拟 DOM 以对象树的形式保存在内存中，并且是可以在任何支持 JavaScript 的环境中生成的，所以可以在浏览器和 Node 中生成，这位前后端同构提供了先决条件")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://img1.3s78.com/codercto/3934a8041495bba7d63267c4ba65caf8",alt:""}})]),e._v(" "),a("p",[e._v("如上图：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("在Node 是可以生成虚拟 DOM 的")])]),e._v(" "),a("li",[a("p",[e._v("虚拟 DOM 可以直接转成 String")])]),e._v(" "),a("li",[a("p",[e._v("然后插入到 HTML 文件中输出给浏览器便可")])])]),e._v(" "),a("p",[e._v("虚拟 Dom 在前后端都是以对象树的形式存在的，但在展露原型的方式确是不一样的")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://img1.3s78.com/codercto/e3bb89b85a40c33a209ad2fd50884025",alt:""}})]),e._v(" "),a("ol",[a("li",[a("p",[e._v("在浏览器里，React 通过 ReactDom 的 render 方法将虚拟 Dom 渲染到真实的 Dom 树上，生成网页")])]),e._v(" "),a("li",[a("p",[e._v("但是在 Node 环境下是没有渲染引擎的，所以 React 提供了另外两个方法："),a("code",[e._v("ReactDOMServer.renderToString")]),e._v(", "),a("code",[e._v("ReactDOMServer.renderToStaticMarkup")])])])]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("ReactDOMServer.renderToString")]),e._v(": 大多数情况应该使用这个方法，这样会为组件增加 "),a("code",[e._v("checksum")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://img1.3s78.com/codercto/f964a6a81ffd1345af6a8b6b434c91b3",alt:""}})]),e._v(" "),a("p",[e._v("React 在客户端通过 "),a("code",[e._v("checksum")]),e._v(" 判断是否需要重新"),a("code",[e._v("render")]),e._v(" 相同则不重新"),a("code",[e._v("render")]),e._v("，省略创建 DOM 和挂 载DOM 的过程，\n接着触发 "),a("code",[e._v("componentDidMount")]),e._v(" 等事件来处理服务端上的未尽事宜(事件绑定等)，从而加快了交互时间；不同时，组件将客户端上被重新挂载 "),a("code",[e._v("render")])]),e._v(" "),a("p",[e._v("checknum 实际上是 HTML 片段的 adler32 算法值，实际上调用 React.render("),a("MyComponent"),e._v(", container); 时候做了下面一些事情：")],1),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("container\ndata-react-checksum\nvar MOD = 65521;\n\n// This is a clean-room implementation of adler32 designed for detecting\n// if markup is not what we expect it to be. It does not need to be\n// cryptographically strong, only reasonably good at detecting if markup\n// generated on the server is different than that on the client.\nfunction adler32(data) {\n  var a = 1;\n  var b = 0;\n  for (var i = 0; i < data.length; i++) {\n    a = (a + data.charCodeAt(i)) % MOD;\n    b = (b + a) % MOD;\n  }\n  return a | (b << 16);\n}\n")])])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("ReactDOMServer.renderToStaticMarkup")]),e._v(": "),a("code",[e._v("renderToStaticMarkup")]),e._v(" 则不会生成与 "),a("code",[e._v("react")]),e._v(" 相关的 "),a("code",[e._v("data-*")]),e._v(" ，也不存在 "),a("code",[e._v("checksum")]),e._v("，输出的 html 如下")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://img1.3s78.com/codercto/ff5605d3dd006471e8e2c30be214d4b0",alt:""}})]),e._v(" "),a("p",[e._v("在客户端时组件会被重新挂载，所以该方法只当服务端上所渲染的组件在客户端不需要时才使用")])])]),e._v(" "),a("h3",{attrs:{id:"不同的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同的生命周期"}},[e._v("#")]),e._v(" 不同的生命周期")]),e._v(" "),a("p",[e._v("在服务端上 Component 生命周期只会到 "),a("code",[e._v("componentWillMount")]),e._v(" ，客户端则是完整的")]),e._v(" "),a("p",[e._v("同构时，服务端结合数据将 Component 渲染成完整的 HTML 字符串并将数据状态返回给客户端，客户端会判断是否可以直接使用或需要重新挂载")]),e._v(" "),a("p",[e._v("以上便是 React 在同构/服务端渲染的提供的基础条件。在实际项目应用中，还需要考虑其他边角问题，例如 服务器 端没有 window 对象，需要做不同处理等")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://www.codercto.com/a/21069.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("React 服务端渲染原理及过程"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=c.exports}}]);