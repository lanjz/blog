import{_ as e,o as i,c as l,e as p}from"./app-usrflJuT.js";const a={},t=p('<h1 id="keep-alive" tabindex="-1"><a class="header-anchor" href="#keep-alive" aria-hidden="true">#</a> keep-alive</h1><h2 id="http-keep-alive" tabindex="-1"><a class="header-anchor" href="#http-keep-alive" aria-hidden="true">#</a> HTTP keep-alive</h2><p>HTTP Keep-Alive，也称为持久连接（Persistent Connection），是HTTP协议的一部分，用于控制在同一TCP连接上连续发送和接收多个HTTP请求和响应，而不是每个请求/响应都打开一个新的连接。它的目的是减少每次请求所需的握手次数，从而减少总体的延迟，提高网络通信的效率</p><ul><li><p>作用层次：应用层。</p></li><li><p>主要目的：减少因建立和关闭TCP连接所产生的开销和延迟，提高页面加载速度。</p></li><li><p>工作机制：在HTTP 1.1中，默认开启Keep-Alive。客户端和服务器在HTTP头部使用 <code>Connection: keep-alive</code> 标志来通知对方保持连接打开，以便后续的请求可以复用现有的连接。</p></li><li><p>优点：减少TCP连接的建立和关闭次数，降低延迟，提高性能。</p></li><li><p>缺点：长时间保持连接可能会占用服务器资源，特别是在高并发环境下</p></li></ul><p><strong>如何关闭 HTTP keep-alive</strong></p><ol><li>如果服务端 Response Header 设置了 <code>Keep-Alive:timeout={timeout}</code>，客户端会就会保持此连接 <code>timeout</code>（单位秒）时间，超时之后关闭连接。</li></ol><p><code>Keep-Alive: timeout=5, max=1000</code></p><ol start="2"><li>客户端发送Header头：<code>Connection: close</code></li></ol><h2 id="tcp-keep-alive" tabindex="-1"><a class="header-anchor" href="#tcp-keep-alive" aria-hidden="true">#</a> tcp keep-alive</h2><p>TCP Keep-Alive是一种网络协议机制，用于检测TCP连接上的另一端是否仍然可达，即对方是否还“活着”。它通过在连接上发送探测包来实现，如果在指定的时间内没有收到响应，就认为连接已经断开。</p><ul><li><p>作用层次：传输层。</p></li><li><p>主要目的：检测死链接，确保连接的双方仍然可达。</p></li><li><p>工作机制：在TCP连接空闲一段时间后，通过发送探测包给对方。如果连续几次探测都没有响应，则认为连接已经断开，TCP层会关闭这个连接。</p></li><li><p>优点：能够自动检测并关闭无效的连接，释放资源。</p></li><li><p>缺点：如果配置不当，可能会导致不必要的流量和功耗。</p></li></ul>',11),o=[t];function c(n,d){return i(),l("div",null,o)}const s=e(a,[["render",c],["__file","keep-alive.html.vue"]]);export{s as default};
