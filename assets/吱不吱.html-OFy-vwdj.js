import{_ as n,r as o,o as d,c,b as e,d as t,a as s,e as r}from"./app-Ald2FT2K.js";const i="/lanjz/assets/scoped-2Ty7X0da.jpg",p={},l=r('<h1 id="吱不吱" tabindex="-1"><a class="header-anchor" href="#吱不吱" aria-hidden="true">#</a> 吱不吱</h1><h3 id="在使用计算属性的时-函数名和-data-数据源中的数据可以同名吗" tabindex="-1"><a class="header-anchor" href="#在使用计算属性的时-函数名和-data-数据源中的数据可以同名吗" aria-hidden="true">#</a> 在使用计算属性的时，函数名和 data 数据源中的数据可以同名吗？</h3><p>可以同名，但 <code>data</code> 会覆盖 <code>methods</code>。因为<code>Props</code>、<code>methods</code>、<code>data</code>、<code>computed</code>、<code>watch</code> 都是在 <code>initState</code> 函数中被初始化的。初始化顺序就是我上面给出的顺序，本质上这些都是要挂载到 <code>this</code> 上面的，如果重名的话，后面出现的属性自然而然会覆盖之前挂载的属性了。</p><h3 id="跟keep-alive有关的生命周期是哪些-描述下这些生命周期" tabindex="-1"><a class="header-anchor" href="#跟keep-alive有关的生命周期是哪些-描述下这些生命周期" aria-hidden="true">#</a> 跟keep-alive有关的生命周期是哪些？描述下这些生命周期</h3><ul><li><p><code>activated</code>: 动态组件激活时执行，包括首次显示在<code>mounted</code>后执行</p></li><li><p><code>deactivatd</code>: 动态组件离开时执行</p></li></ul><h3 id="vue中怎么重置data" tabindex="-1"><a class="header-anchor" href="#vue中怎么重置data" aria-hidden="true">#</a> vue中怎么重置data</h3><p>vue组件有两个属性：</p><ul><li><p><code>this.$data</code>: 当前状态下的 <code>data</code></p></li><li><p><code>this.$options.data()</code>: 获取初化状态下的 <code>data</code></p></li></ul><p>所以重置 <code>data</code> 的方式为：<code>Object.assign(this.$data, this.$options.data())</code></p><h3 id="style加scoped属性的用途和原理" tabindex="-1"><a class="header-anchor" href="#style加scoped属性的用途和原理" aria-hidden="true">#</a> style加scoped属性的用途和原理</h3><p>用途：<code>防止污染同名的CSS样式</code></p><p>原理：在标签加上 <code>v-data-something</code> 属性，再在选择器时加上对应 <code>[v-data-something]</code> ，即 CSS 带属性选择器，以此完成类似作用域的选择方式</p><p><img src="'+i+`" alt=""></p><h3 id="vue的错误捕获" tabindex="-1"><a class="header-anchor" href="#vue的错误捕获" aria-hidden="true">#</a> vue的错误捕获</h3><ul><li><p><code>errorCaptured</code>: <code>errorCaptured</code> 是组件内部钩子，可捕捉本组件与子孙组件抛出的错误，接收<code>error</code>、<code>vm</code>、<code>info</code> 三个参数，<code>return false</code> 后可以阻止错误继续向上抛出</p></li><li><p><code>errorHandler</code> 为全局钩子，使用 <code>Vue.config.errorHandler</code> 配置，接收参数与<code>errorCaptured </code>一致</p></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function-variable function">errorHandler</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// handle error</span>
  <span class="token comment">// \`info\` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span>
  <span class="token comment">// 只在 2.2.0+ 可用</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="在vue事件中传入-event-使用-e-target-和-e-currenttarget有什么区别" tabindex="-1"><a class="header-anchor" href="#在vue事件中传入-event-使用-e-target-和-e-currenttarget有什么区别" aria-hidden="true">#</a> 在vue事件中传入 <code>$event</code>，使用 <code>e.target</code> 和 <code>e.currentTarget</code>有什么区别</h3><ul><li><p><code>e.currentTarget</code>：绑定事件的对象</p></li><li><p><code>e.target</code>: 真正触发事件的对象</p></li><li><p><code>$event</code>: <code>e</code></p></li></ul><h3 id="vue变量名如果以-、-开头的属性会发生什么问题-怎么访问到它们的值" tabindex="-1"><a class="header-anchor" href="#vue变量名如果以-、-开头的属性会发生什么问题-怎么访问到它们的值" aria-hidden="true">#</a> vue变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值</h3><p>以 <code>_</code> 或 <code>$</code> 开头的属性不会被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性</p><h3 id="vue使用v-for遍历对象时-是按什么顺序遍历的" tabindex="-1"><a class="header-anchor" href="#vue使用v-for遍历对象时-是按什么顺序遍历的" aria-hidden="true">#</a> vue使用v-for遍历对象时，是按什么顺序遍历的</h3><ol><li><p>会先判断是否有 <code>iterator</code> 接口，如果有循环执行 <code>next()</code> 方法</p></li><li><p>没有 <code>iterator</code> 的情况下，会调用 <code>Object.keys()</code> 方法，在不同浏览器中，JS引擎不能保证输出顺序一致</p></li></ol><p>保证对象的输出顺序可以把对象放在数组中，作为数组的元素</p><h3 id="lazy修辞符" tabindex="-1"><a class="header-anchor" href="#lazy修辞符" aria-hidden="true">#</a> .lazy修辞符</h3><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件之后进行同步：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model.lazy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>msg<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,26),u={href:"https://zhuanlan.zhihu.com/p/71229672",target:"_blank",rel:"noopener noreferrer"};function h(v,m){const a=o("ExternalLinkIcon");return d(),c("div",null,[l,e("p",null,[e("a",u,[t("248+个知识点"),s(a)])])])}const f=n(p,[["render",h],["__file","吱不吱.html.vue"]]);export{f as default};
