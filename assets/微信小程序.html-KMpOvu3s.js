import{_ as t,r as o,o as c,c as i,b as n,d as s,a as e,e as p}from"./app-Ald2FT2K.js";const l="/lanjz/assets/mini-xS44Sh7o.png",u="/lanjz/assets/wx_2-ra0DM5Un.png",r="/lanjz/assets/setData-LU5HRG1J.png",d="/lanjz/assets/wx-HIklo_C-.png",k="/lanjz/assets/diff-bMZproei.png",v="data:image/png;base64,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",m="/lanjz/assets/event1-UUbO6R3u.png",b={},g=p(`<h1 id="微信小程序运行原理" tabindex="-1"><a class="header-anchor" href="#微信小程序运行原理" aria-hidden="true">#</a> 微信小程序运行原理</h1><p>微信小程序介于 web 与 原生app 之间的混合app，具备丰富的调用手机各种功能的接口，同时又具备灵活性，跨平台</p><h2 id="基本特点" tabindex="-1"><a class="header-anchor" href="#基本特点" aria-hidden="true">#</a> 基本特点</h2><h3 id="小程序与普通网页开发的区别" tabindex="-1"><a class="header-anchor" href="#小程序与普通网页开发的区别" aria-hidden="true">#</a> 小程序与普通网页开发的区别</h3><ul><li><p>网页开发中，渲染线程JS线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，两者可以直接进行通信</p></li><li><p>小程序的逻辑层和渲染层是分开的，分别运行在不同的线程中，所不能直接进行通信。同时借助微信提供的API可以调用原生功能</p></li></ul><h3 id="小程序目录结构" tabindex="-1"><a class="header-anchor" href="#小程序目录结构" aria-hidden="true">#</a> 小程序目录结构</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>project
├── pages
|   ├── index
|   |   ├── index.json  index 页面配置
|   |   ├── index.js    index 页面逻辑
|   |   ├── index.wxml  index 页面结构
|   |   └── index.wxss  index 页面样式表
|   └── log
|       ├── log.json    log 页面配置
|       ├── log.wxml    log 页面逻辑
|       ├── log.js      log 页面结构
|       └── log.wxss    log 页面样式表
├── app.js              小程序逻辑
├── app.json            小程序公共设置
└── app.wxss            小程序公共样式表
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="为什么小程序快" tabindex="-1"><a class="header-anchor" href="#为什么小程序快" aria-hidden="true">#</a> 为什么小程序快</h3><ul><li><p>安装包缓存</p></li><li><p>分包加载</p></li><li><p>独立渲染线程</p></li><li><p>Webview 预加载</p></li><li><p>Native组件</p></li></ul><h3 id="小程序启动加载" tabindex="-1"><a class="header-anchor" href="#小程序启动加载" aria-hidden="true">#</a> 小程序启动加载</h3><p>小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。</p><ul><li><p>热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动</p></li><li><p>冷启动：指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。</p></li></ul><h3 id="更新机制" tabindex="-1"><a class="header-anchor" href="#更新机制" aria-hidden="true">#</a> 更新机制</h3><p>小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。 如果需要马上应用最新版本，可以使用 <code>wx.getUpdateManager</code> API 进行处理。</p><h3 id="运行机制" tabindex="-1"><a class="header-anchor" href="#运行机制" aria-hidden="true">#</a> 运行机制</h3><ul><li><p>小程序没有重启的概念</p></li><li><p>当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁</p></li><li><p>当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁</p></li></ul><h3 id="执行环境" tabindex="-1"><a class="header-anchor" href="#执行环境" aria-hidden="true">#</a> 执行环境</h3><p>微信小程序运行在三端：iOS、Android 和 用于调试的开发者工具</p><p>三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</p><ul><li><p>在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中，是由 WKWebView 来渲染的，环境有 iOS8、iOS9、iOS10</p></li><li><p>在 Android 上，小程序的 javascript 代码是通过 X5 JSCore来解析，是由 X5 基于 Mobile Chrome 53/57 内核来渲染的</p></li><li><p>在 开发工具上， 小程序的 javascript 代码是运行在 nwjs 中，是由 Chrome Webview 来渲染的</p></li></ul><h3 id="小程序基础库" tabindex="-1"><a class="header-anchor" href="#小程序基础库" aria-hidden="true">#</a> 小程序基础库</h3><p>小程序基础库就同 JS-SDK 类似，为当前应用调起手机系统能力和微信能力，两者的不同点在于：</p><ul><li><p>支持的API：小程序基础库对系统能力和微信能力做了更全面的封装，包括网络请求、存储等，而网页版JS-SDK相应的功能直接调用window能力</p></li><li><p>引入方式：小程序基础库直接集成到微信的不同版本中，JS-SDK是以一个js文件的形式被引入项目里；</p></li></ul><h4 id="小程序基础库与微信客户端之间的关系" tabindex="-1"><a class="header-anchor" href="#小程序基础库与微信客户端之间的关系" aria-hidden="true">#</a> 小程序基础库与微信客户端之间的关系</h4><p>小程序的能力需要微信客户端来支撑，每一个基础库都只能在对应的客户端版本上运行，高版本的基础库无法兼容低版本的微信客户端</p><p>官方的这种说法存在一些问题。现在基础库版本和客户端版本并不是一一对应关系。客户端可以主动升级小程序基础库版本达到灰度上线新版的目的，所以必然存在一个客户端版本对应多个基础库版本的情况</p><p><strong>小程序基础库更新时机</strong></p><p>为了避免新版本的基础库给线上小程序带来未知的影响，微信客户端都是携带 上一个稳定版 的基础库发布的。<br> 在新版本客户端发布后，我们再通过后台灰度新版本基础库，灰度时长一般为 12 小时，在灰度结束后，用户设备上才会有新版本的基础库</p><p>以微信 6.5.8 为例，客户端在发布时携带的是 1.1.1 基础库（6.5.7上已全量的稳定版）发布，在 6.5.8 发布后，我们再通过后台灰度 1.2.0 基础库。</p><p>“细思恐极”，如果我们已经完成一台装有 6.5.4 版本微信的Oppo手机对小程序的兼容测试，很有可能过几天这台Oppo手机将小程序基础库更新到新版本导致小程序不可用。建议：了解产品的用户手机微信版本分布，确定回归覆盖范围，完成回归测试。</p><h3 id="小程序开发特点" tabindex="-1"><a class="header-anchor" href="#小程序开发特点" aria-hidden="true">#</a> 小程序开发特点</h3><p>小程序存在的问题</p><ul><li><p>小程序仍然使用WebView渲染，并非原生渲染</p></li><li><p>需要独立开发，不能在非微信环境运行</p></li><li><p>开发者不可以扩展新组件</p></li><li><p>WXSS中无法使用本地（图片、字体等）</p></li><li><p>WXSS转化成js 而不是css。</p></li><li><p>WXSS不支持级联选择器</p></li></ul><p>小程序的优点</p><ul><li><p>提前新建 WebView，准备新页面渲染</p></li><li><p>使用 Virtual DOM，进行局部更新</p></li><li><p>全部使用 <code>https</code>，确保传输中安全</p></li><li><p>加入 <code>rpx</code> 单位，隔离设备尺寸，方便开发</p></li></ul><h2 id="小程序架构" tabindex="-1"><a class="header-anchor" href="#小程序架构" aria-hidden="true">#</a> 小程序架构</h2><p>这是一个比较通用的小程序架构，目前几家小程序架构设计大致都是这样的</p><p><img src="`+l+'" alt=""></p><p>微信小程序的框架包含两部分：</p><ul><li><p><code>App Service逻辑层</code>：App Service逻辑层(一个)用来逻辑处理、数据请求、接口调用，它们在两个线程里运行，逻辑层使用JSCore运行</p></li><li><p><code>View层</code>：View视图层(可能存在多个)用来渲染页面结构， 使用WebView渲染</p></li></ul><p><strong>逻辑层</strong></p><p>逻辑层就是上图左上角这块，小程序中开发的所有页面JS代码，最后都会打包合并到逻辑层，逻辑层除了执行开发者的业务JS代码外，还需处理小程序框架的内置逻辑，比如App生命周期管理</p><p>逻辑层最后运行在JS CORE或V8环境中；JS CORE既不是DOM环境，也不是node环境，所以无法使用 JS 中的 DOM 或 BOM 对象的，你能调用的仅仅是 ECMAScript 标准规范中所给出的方法<br> 那如果你要发送网络请求怎么办？<code>window.XMLHttpRequest</code> 是无法使用的。这时候，网络请求就需要通过原生的网络模块来发送</p><p><strong>视图层</strong></p><p>视图层就是上图右上角这块，用户可见的UI效果、可触发的交互事件在视图层完成</p><h3 id="通信" tabindex="-1"><a class="header-anchor" href="#通信" aria-hidden="true">#</a> 通信</h3><p>视图层和逻辑层通过系统层的 <code>WeixinJsBridage</code> 进行通信，逻辑层把数据变化通过 <code>setData</code> 通知到视图层，触发视图层页面更新；视图层通过事件触发事件通知到逻辑层进行业务处理，下面我们详细说明他们的细节原理</p><p><img src="'+u+'" alt=""></p><p>这张生命周期图非常详尽的描述了一个页面从创建入栈、数据交互、销毁出栈的整个过程。在页面渲染和使用过程中会出现大量的事件，而这些事件会被JsBridge捕获到，并传递给逻辑层处理，主要包括：生命周期事件、UI事件</p><p><strong>生命周期事件</strong></p><p>视图进程在完成阶段性工作后，需要向逻辑层同步其当前状态以便逻辑层做出应对策略。主要包括：<code>onLoad</code>、<code>onReady</code>、<code>onShow</code>、<code>onHide</code>、<code>onUnload</code>、<code>onPullDownRefresh</code>、<code>onReachBottom</code>、<code>onShareAppMessage</code> 等</p><p><strong>UI事件</strong></p><p>视图层向逻辑层的通信方式</p><p>这类事件绑定在组件上，触发则可以将用户的行为反馈到逻辑层对应的注册函数，如 <code>bindtap</code>、<code>bindinput</code>、<code>bindconfirm</code>、<code>bindfocus</code>、<code>bindsubmit</code>、<code>bindchange</code>、<code>bindlinechange</code> 等</p><p><strong>Page.prototype.setData()</strong></p><p>逻辑层向视图层发送数据更新并触发页面渲染的方式</p><p>数据的传输实际上是通过两边提供的 <code>evaluateJavascript</code> 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。</p><p><code>setData</code> 工作原理图：</p><p><img src="'+r+'" alt=""></p><p>而 <code>evaluateJavascript</code> 的执行会受很多方面的影响，数据到达视图层并不是实时的。所以我们的 <code>setData</code> 函数将数据从逻辑层发送到视图层，是异步的</p><p><img src="'+d+`" alt=""></p><p>这张图展示了视图层、逻辑层之间通信方式,以及JsBridge起到纽带的作用。我们可以做以下几点总结：</p><ul><li><p>视图层和逻辑层分开在两个线程中运行</p></li><li><p>视图层、逻辑层通过事件完成通信</p></li><li><p>JsBridge一方面传递基础功能，另一方面做视图层和逻辑层的数据传递工作</p></li></ul><h2 id="架构缺陷与优化手段" tabindex="-1"><a class="header-anchor" href="#架构缺陷与优化手段" aria-hidden="true">#</a> 架构缺陷与优化手段</h2><p>小程序这种架构主要有两大好处</p><ol><li><p>不能直接操控 DOM，一定程度保护页面的安全性</p></li><li><p>最大的好处是新页面加载可以并行，让页面加载更快，即使业务逻辑计算非常繁忙，也不会阻塞渲染和用户在视图层上的交互</p></li></ol><p>但同时也引发了部分性能坑点，主要体现通信性能方面</p><h3 id="逻辑层-视图层通讯阻塞" tabindex="-1"><a class="header-anchor" href="#逻辑层-视图层通讯阻塞" aria-hidden="true">#</a> 逻辑层/视图层通讯阻塞</h3><p>小程序的运行环境分为逻辑层和视图层，分别由2个线程管理。数据更新及事件系统只能靠线程间通讯，但跨线程通信的成本极高，特别是需要频繁通信的场景<br> 比如需要监听页面滚动或者手指滑动事件去做交互功能时，高频率的回调导致通讯成本大幅增加，极有可能导致页面卡顿或抖动。为什么会卡顿，因为通讯太过频繁，视图层响应更新跟不上（无法在16毫秒内完成UI更新）</p><p><strong>优化手段：所以平时应该要尽量少得去调用 <code>setData</code>，控制制作频率</strong></p><h3 id="数据差量更新" tabindex="-1"><a class="header-anchor" href="#数据差量更新" aria-hidden="true">#</a> 数据差量更新</h3><p>上文了解到逻辑层和视图层的数据传递需要将数据转成字符串再拼接成 JS 脚本，通过执行脚本的形式进行更新通知，所以当数据量过大时会增加脚本的编译执行时间</p><p><strong>优化手段：差量更新、控制数据结构的大小和深度（官方限制data数据量最大为1024K)</strong></p><p>假设有一个 <code>userinfo</code> 对象，当更新了姓名字段时，我们可能使用下面代码进行更新</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">userinfo</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>userinfo<span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">99</span>  
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上代码， 会将完整的 <code>userinfo</code> 对象通过 <code>setData</code> 全部传输过去，而实际上变化的数据只有 <code>age</code> 一个属性</p><p>开发者在这种场景下，应通过差量计算，仅通过 <code>setData</code> 传递变化的数据，如下是一个示例代码:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token string-property property">&#39;userinfo.age&#39;</span><span class="token operator">:</span> <span class="token number">99</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样可实现传递数据量的最小化，提升通讯性能</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>现在一些成熟的小程序三方框架已经自动封装差量数据计算，比如 uni-app 借鉴了 <code>westore JSON Diff</code> 库，在调用 <code>setData</code> 之前，会先比对历史数据，精确高效计算出有变化的差量数据</p></div><h3 id="组件差量更新" tabindex="-1"><a class="header-anchor" href="#组件差量更新" aria-hidden="true">#</a> 组件差量更新</h3><p>微信小程序的视图更新的颗粒度是组件级别的</p><p><img src="`+k+'" alt=""></p><p>比如上面的图例，将点赞数发生变化时，在传统模式下会造成整个页面产生的 diff 操作再做视图更新，计算效率极低</p><p><strong>优化手段：将高频更新的区域独立做成组件（例子中的点赞部分），这样 diff 的范围就会控制在组件级别</strong></p>',85),h={id:"官方优化建议",tabindex:"-1"},f=n("a",{class:"header-anchor",href:"#官方优化建议","aria-hidden":"true"},"#",-1),y={href:"https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start.html",target:"_blank",rel:"noopener noreferrer"},x=n("h3",{id:"启动性能优化",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#启动性能优化","aria-hidden":"true"},"#"),s(" 启动性能优化")],-1),w=n("p",null,[n("strong",null,"代码包体积优化")],-1),j=n("p",null,"启动性能优化的核心手段是降低代码包大小，代码包大小直接影响了下载耗时，影响用户启动小程序时的体验。",-1),P=n("p",null,"开发者可以采取以下手段优化代码包大小：",-1),_={href:"https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html",target:"_blank",rel:"noopener noreferrer"},S={href:"https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/preload.html",target:"_blank",rel:"noopener noreferrer"},O={href:"https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/independent.html",target:"_blank",rel:"noopener noreferrer"},q={href:"https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html",target:"_blank",rel:"noopener noreferrer"},A=n("p",null,[n("strong",null,"代码重构和优化")],-1),M=n("p",null,[s("通过代码重构，降低代码冗余。在使用如 Webpack 等打包工具时，要尽量利用 "),n("code",null,"tree-shaking"),s(" 等特性去除冗余代码，也要注意防止打包时引入不需要的库和依赖")],-1),R=n("p",null,[n("strong",null,"控制代码包内图片等资源")],-1),E=n("p",null,"避免在代码包中包含或在 WXSS 中使用 base64 内联过多、过大的图片，应尽量采用网络图片。代码包内的图片一般应只包含一些体积较小的图标。音频、视频、字体等其他类型的资源也应尽量避免放到代码包中。",-1),D=n("p",null,"小程序代码包在下载时会使用 ZSTD 算法进行压缩，这些资源文件会占用大量代码包体积，并且通常难以进一步被压缩，对于下载耗时的影响比代码文件大得多",-1),C=n("p",null,[n("strong",null,"及时清理没有使用到的代码和资源"),s(" 在日常开发的时候，我们可能引入了一些新的库文件，而过了一段时间后，由于各种原因又不再使用这个库了，我们常常会只是去掉了代码里的引用，而忘记删掉这类库文件了。")],-1),N={href:"https://developers.weixin.qq.com/miniprogram/dev/devtools/codeanalyse.html",target:"_blank",rel:"noopener noreferrer"},T=p("<p><strong>减少启动过程的同步调用</strong></p><p>在小程序启动流程中，会注入开发者代码并顺序同步执行 <code>App.onLaunch</code>, <code>App.onShow</code>, <code>Page.onLoad</code>, <code>Page.onShow</code>。在小程序初始化代码（Page，App 定义之外的内容）和启动相关的几个生命周期中，应避免执行复杂的计算逻辑或过度使用 <code>Sync</code> 结尾的同步 API，如 <code>wx.getStorageSync</code>，<code>wx.getSystemInfoSync</code> 等。对于 <code>getSystemInfo</code>, <code>getSystemInfoSync</code> 的结果应进行缓存，避免重复调用</p>",2),H={href:"https://developers.weixin.qq.com/miniprogram/dev/framework/ability/lazyload.html#%E6%8C%89%E9%9C%80%E6%B3%A8%E5%85%A5",target:"_blank",rel:"noopener noreferrer"},J=p(`<p>通常情况下，在小程序启动时，启动页面所在分包和主包（独立分包除外）的所有 JS 代码会全部合并注入，包括其他未访问的页面以及未用到自定义组件，造成很多没有使用的代码注入到小程序运行环境中，影响注入耗时和内存占用。</p><p>自基础库版本 2.11.1 起，可以通过开启「按需注入」特性避免无用代码注入，以降低小程序的启动时间和运行时内存</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token string-property property">&quot;lazyCodeLoading&quot;</span><span class="token operator">:</span> <span class="token string">&quot;requiredComponents&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),I={href:"https://developers.weixin.qq.com/miniprogram/dev/framework/ability/lazyload.html#%E7%94%A8%E6%97%B6%E6%B3%A8%E5%85%A5",target:"_blank",rel:"noopener noreferrer"},z=n("p",null,"在打开上述「按需注入」特性的前提下，可以通过「用时注入」特性进一步使一部分自定义组件不在启动时注入，而是在真正被渲染时才进行注入，进一步降低小程序的启动和首屏时间",-1),U=n("p",null,[n("strong",null,"提前首屏数据请求")],-1),Q=n("p",null,"大部分小程序在渲染首页时，需要依赖服务端的接口数据，小程序为开发者提供了提前发起数据请求的能力：",-1),V={href:"https://developers.weixin.qq.com/miniprogram/dev/framework/ability/pre-fetch.html",target:"_blank",rel:"noopener noreferrer"},B={href:"https://developers.weixin.qq.com/miniprogram/dev/framework/ability/background-fetch.html",target:"_blank",rel:"noopener noreferrer"},L=p("<p><strong>骨架屏</strong></p><p>在页面数据未准备好时（如需要通过网络获取），尽量避免展示空白页面，应先通过骨架屏展示页面的大致结构，请求数据返回后在进行页面更新。以提升用户的等待意愿</p><p><strong>缓存请求数据</strong></p><p>小程序提供了 <code>wx.setStorage</code>、<code>wx.getStorage</code> 等读写本地缓存的能力，数据存储在本地，返回的会比网络请求快。如果开发者基于某些原因无法采用数据预拉取与周期性更新，我们推荐优先从缓存中获取数据来渲染视图，等待网络请求返回后进行更新</p><p><strong>精简首屏数据</strong></p><p>我们推荐开发者延迟请求非关键渲染数据，与视图层渲染无关的数据尽量不要放在 <code>data</code> 中，加快页面渲染完成时间</p><p><strong>启用「初始渲染缓存」</strong></p>",7),X={href:"https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html",target:"_blank",rel:"noopener noreferrer"},K=n("code",null,"data",-1),Z=n("p",null,[n("strong",null,"数据预加载")],-1),W={href:"https://segmentfault.com/a/1190000016072570",target:"_blank",rel:"noopener noreferrer"},G=p('<p>原理</p><p>小程序在启动时，会直接加载所有页面逻辑代码进内存，即便 page2 可能都不会被使用。在 page1 跳转至 page2 时，page1 的逻辑代码 Javascript 数据也不会从内存中消失。 page2 甚至可以直接访问 page1 中的数据</p><p>小程序的这种机制差异正好可以更好的实现预加载。通常情况下，我们习惯将数据拉取写在 onLoad 事件中。但是小程序的 page1 跳转到 page2，到 page2 的 onLoad 是存在一个 300ms ~ 400ms 的延时的。如下图：</p><p>在 <code>pageA</code> 跳到 <code>pageB</code> 的时候，在 <code>pageB</code> 使用 <code>onNavigate</code> 生命周期来在页面B即将被加载时运行</p><h3 id="运行时性能优化" tabindex="-1"><a class="header-anchor" href="#运行时性能优化" aria-hidden="true">#</a> 运行时性能优化</h3><h4 id="setdata-使用" tabindex="-1"><a class="header-anchor" href="#setdata-使用" aria-hidden="true">#</a> setData 使用</h4><p>常见的 <code>setData</code> 操作错误</p><ul><li><p>频繁的去 <code>setData</code></p><p>在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去 <code>setData</code>，其导致了两个后果：</p><ul><li><p>Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；</p><p>渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；</p></li></ul></li><li><p>每次 <code>setData</code> 都传递大量新数据</p><p>由 <code>setData</code> 的底层实现可知，我们的数据传输实际是一次 <code>evaluateJavascript</code> 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程</p></li><li><p>当页面进入后台态（用户不可见），不应该继续去进行 <code>setData</code>，后台态页面的渲染用户是无法感受的，另外后台态页面去 <code>setData</code> 也会抢占前台页面的执行。</p></li></ul><h4 id="图片资源" tabindex="-1"><a class="header-anchor" href="#图片资源" aria-hidden="true">#</a> 图片资源</h4><p>目前图片资源的主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面</p><p>在 iOS 上，小程序的页面是由多个 WKWebView 组成的，在系统内存紧张时，会回收掉一部分 WKWebView。从过去我们分析的案例来看，大图片和长列表图片的使用会引起 WKWebView 的回收。</p><p>除了内存问题外，大图片也会造成页面切换的卡顿。我们分析过的案例中，有一部分小程序会在页面中引用大图片，在页面后退切换中会出现掉帧卡顿的情况。</p><p>当前我们建议开发者尽量减少使用大图片资源</p>',13),Y={href:"https://juejin.im/post/5afd136551882542682e6ad7",target:"_blank",rel:"noopener noreferrer"},F=n("br",null,null,-1),$={href:"https://juejin.cn/post/6844903485691920392#heading-13",target:"_blank",rel:"noopener noreferrer"},nn=n("br",null,null,-1),sn={href:"https://developers.weixin.qq.com/community/develop/article/doc/0008a4c4f28f30fe3eb863b2750813",target:"_blank",rel:"noopener noreferrer"},an=p(`<h2 id="小程序实现mixin" tabindex="-1"><a class="header-anchor" href="#小程序实现mixin" aria-hidden="true">#</a> 小程序实现Mixin</h2><p>在小程序中，每个页面都由 <code>Page(options)</code> 函数定义，而 <code>Mixins</code> 则作用于这个函数当中的 <code>options</code> 对象。因此我们实现 <code>Mixins</code> 的思路就有了——劫持并改写 <code>Page</code> 函数，最后再重新把它释放出来</p><p>新建一个 <code>mixins.js</code> 文件：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 保存原生的 Page 函数</span>
<span class="token keyword">const</span> originPage <span class="token operator">=</span> Page

<span class="token function-variable function">Page</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> mixins <span class="token operator">=</span> options<span class="token punctuation">.</span>mixins
  <span class="token comment">// mixins 必须为数组</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>mixins<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">delete</span> options<span class="token punctuation">.</span>mixins
    <span class="token comment">// mixins 注入并执行相应逻辑</span>
    options <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>mixins<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 释放原生 Page 函数</span>
  <span class="token function">originPage</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是混入时需要注意几点：</p><ol><li><p>对于 <code>data</code>, <code>properties</code>, <code>options</code> 这类内置的属性以及自定义的方法，混入的规则是能合并则合并，碰到同属性则以页面的属性为优先</p></li><li><p>对于生命周期类的函数，页面的生命周期和 <code>mixin</code> 的生命周期都应该要执行，不能直接覆盖</p></li></ol><p>所以上例中的 <code>merge</code> 方法的实现如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 定义小程序内置的属性/方法</span>
<span class="token keyword">const</span> originProperties <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;data&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;properties&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;options&#39;</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> originMethods <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;onLoad&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;onReady&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;onShow&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;onHide&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;onUnload&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;onPullDownRefresh&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;onReachBottom&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;onShareAppMessage&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;onPageScroll&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;onTabItemTap&#39;</span><span class="token punctuation">]</span>

<span class="token keyword">function</span> <span class="token function">merge</span> <span class="token punctuation">(</span><span class="token parameter">mixins<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  mixins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">mixin</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>mixin<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">&#39;[object Object]&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;mixin 类型必须为对象！&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历 mixin 里面的所有属性</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>mixin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>originProperties<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 内置对象属性混入</span>
        options<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>value<span class="token punctuation">,</span> <span class="token operator">...</span>options<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>originMethods<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 内置方法属性混入，优先执行混入的部分</span>
        <span class="token keyword">const</span> originFunc <span class="token operator">=</span> options<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        options<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
          <span class="token keyword">return</span> originFunc <span class="token operator">&amp;&amp;</span> <span class="token function">originFunc</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 自定义方法混入</span>
        options <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>mixin<span class="token punctuation">,</span> <span class="token operator">...</span>options <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> options
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Mixins 使用</strong></p><ol><li>在小程序的 app.js 里引入 mixins.js</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./mixins.js&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>撰写一个 myMixin.js</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">someData</span><span class="token operator">:</span> <span class="token string">&#39;myMixin&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">onShow</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Log from mixin!&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>在 <code>pages/index/index.js</code> 中使用</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">mixins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;../../myMixin.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这样使用只有 <code>pages/index/index.js</code> 页面将混入配置的 <code>mixins</code></p><p>如果希望全局所有页面都混入 <code>mixins</code>，需要在 <code>mixins.js</code> 配置直接混入配置</p><p>如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> originPage <span class="token operator">=</span> Page

<span class="token keyword">let</span> globalMinxin <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token function">onShow</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Log from globalMinxin!&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
<span class="token function-variable function">Page</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> mixins <span class="token operator">=</span> options<span class="token punctuation">.</span>mixins
  <span class="token comment">// mixins 必须为数组</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>mixins<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">delete</span> options<span class="token punctuation">.</span>mixins
    <span class="token comment">// mixins 注入并执行相应逻辑</span>
    options <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>globalMinxin<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
    options <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>mixins<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 释放原生 Page 函数</span>
  <span class="token function">originPage</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="小程序异常监控实现方案" tabindex="-1"><a class="header-anchor" href="#小程序异常监控实现方案" aria-hidden="true">#</a> 小程序异常监控实现方案</h2><p>小程序 <code>App()</code> 生命周期里提供了 <code>onError</code> 函数，可以通过在 <code>onError</code> 里收集异常信息</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 监听错误</span>
  <span class="token function-variable function">onError</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 上报错误</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;onError&#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>函数调用跟踪</strong></p><p>只有错误栈信息排查起来会比较难，因此我们可以记录函数的调用来方便来收集用户的操作路径</p><p>实现方法类型上文提到的扩展 App 中钩子类似，我们可以劫持页面上的方法来记录函数的调用</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> originPage <span class="token operator">=</span> Page
<span class="token function-variable function">Page</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">methodName</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">typeof</span> options<span class="token punctuation">[</span>methodName<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span>
      <span class="token operator">&amp;&amp;</span> <span class="token function">recordPageFn</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 释放原生 Page 函数</span>
  <span class="token function">originPage</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">recordPageFn</span><span class="token punctuation">(</span><span class="token parameter">page<span class="token punctuation">,</span> methodName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> userDefinedMethod <span class="token operator">=</span> page<span class="token punctuation">[</span>methodName<span class="token punctuation">]</span><span class="token punctuation">;</span>
  page<span class="token punctuation">[</span>methodName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> breadcrumb <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">belong</span><span class="token operator">:</span> <span class="token string">&#39;Page&#39;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">method</span><span class="token operator">:</span> methodName<span class="token punctuation">,</span>
      <span class="token literal-property property">arguments</span><span class="token operator">:</span> arguments
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>breadcrumb<span class="token punctuation">)</span>
    <span class="token keyword">return</span> userDefinedMethod <span class="token operator">&amp;&amp;</span> <span class="token function">userDefinedMethod</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就可以得到页面函数的调用记录了</p><p><strong>上报策略</strong></p><p>考虑到在大型应用中，日志量比较大，我们采取抽样，合并，过滤三个方法减少日志的输出</p>`,29),en={href:"https://github.com/zhengguorong/xbossdebug-wechat",target:"_blank",rel:"noopener noreferrer"},pn={href:"https://developers.weixin.qq.com/community/develop/doc/000e46078b015804f6d6c2dc156006",target:"_blank",rel:"noopener noreferrer"},tn={href:"https://juejin.cn/post/6844904046709440519#heading-8",target:"_blank",rel:"noopener noreferrer"},on=p(`<h2 id="小程序埋点收集设计" tabindex="-1"><a class="header-anchor" href="#小程序埋点收集设计" aria-hidden="true">#</a> 小程序埋点收集设计</h2><p>就简单的埋点收集方法是在页面的生命周期钩子处和触发事件的地方手动添加埋点收集方法，这种方式的优点是埋点比较准确，但是缺点也很多，如：</p><ul><li><p>需要在每需要埋点的地方手动添加收集事件</p></li><li><p>当需要对埋点对于增加或减少了时候，需要开发手动去修改代码然后重新审核</p></li><li><p>收集埋点事件与实际业务代码产生了耦合</p></li></ul><p>所以本文收集一下如何实现小程序自动化埋点，最动的目的是达到下几两点功能：</p><ul><li><p>与业务代码解耦</p></li><li><p>可以通过接口来获取要埋点的按钮的配置信息，然后自动根据配置信息进行埋点的收集</p></li></ul><h3 id="页面加载的埋点" tabindex="-1"><a class="header-anchor" href="#页面加载的埋点" aria-hidden="true">#</a> 页面加载的埋点</h3><p>页面加载的埋点比较简单，可以使用上文所说的扩展 <code>Page</code> 添加 <code>Mixin</code> 的方式进行处理</p><h3 id="元素埋点-冒泡埋点" tabindex="-1"><a class="header-anchor" href="#元素埋点-冒泡埋点" aria-hidden="true">#</a> 元素埋点-冒泡埋点</h3><p>冒泡埋点不是最终方案，但是也是一种方法所以也记录一下。冒泡埋点其实就是模仿事件委托的方式进行统一的事件处理，这种方式优点是省去了给元素一个个添加事件这种烦锁的步骤。具体实现方式步骤：</p><ol><li><p><strong>扩展Page方法</strong>，给每个页面添加一个收集埋点的事件</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 记录原Page方法</span>
<span class="token keyword">const</span> originPage <span class="token operator">=</span> Page<span class="token punctuation">;</span>
<span class="token comment">// 重写Page方法</span>
<span class="token function-variable function">Page</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">page</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 添加一个收集埋点事件的方法</span>
  page<span class="token punctuation">.</span><span class="token function-variable function">elementTracker</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">originPage</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在页面的根元素添加事件绑定</p></li></ol><p>冒泡采集相比传统的方式比较轻量级，无需注入大量代码。<strong>但是依赖于冒泡事件，假如原来的业务代码阻止了冒泡，那就获取不了，可靠性比较差</strong></p><h3 id="元素埋点-扩展所有的页面方法" tabindex="-1"><a class="header-anchor" href="#元素埋点-扩展所有的页面方法" aria-hidden="true">#</a> 元素埋点-扩展所有的页面方法</h3><p>所有的埋点元素事件必然存在对事的函数事件，所以可以从绑定的函数进行入手。思路为：跟扩展 Page 添加 Mixin 类似，可以对逻辑层的每个函数提供 <code>hook</code> 方法，在 <code>hook</code> 收集用户的点击事件</p><p>具体实现：在小程序启动的时候，重构 <code>Page()</code> 和 <code>Component()</code> 这两个系统对象，遍历对象里面的所有属性，如果属性类型是函数，则进一步判断是否在忽略名单，像监听页面滚动的函数这种是不需要添加 hook 的，最后才是给函数添加 hook</p><p>eg:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string-property property">&quot;pages/index/index&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string-property property">&quot;bindViewTap &quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;usename&#39;</span><span class="token punctuation">]</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string-property property">&quot;pages/log/index&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string-property property">&quot;bindlogTap &quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;logId&#39;</span><span class="token punctuation">]</span>
   <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span class="token comment">// 保存原生的 Page 函数</span>
<span class="token comment">// 保存原生的 Component 函数</span>
<span class="token keyword">const</span> originPage <span class="token operator">=</span> Page
<span class="token keyword">const</span> originComponent <span class="token operator">=</span> Component
<span class="token function-variable function">Component</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>methods<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">methodName</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">recordPageFn</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>methods<span class="token punctuation">,</span> methodName<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 释放原生 Page 函数</span>
  <span class="token function">originComponent</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function-variable function">Page</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">methodName</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">typeof</span> options<span class="token punctuation">[</span>methodName<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">recordPageFn</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 释放原生 Page 函数</span>
  <span class="token function">originPage</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">recordPageFn</span><span class="token punctuation">(</span><span class="token parameter">page<span class="token punctuation">,</span> methodName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> userDefinedMethod <span class="token operator">=</span> page<span class="token punctuation">[</span>methodName<span class="token punctuation">]</span><span class="token punctuation">;</span>
  page<span class="token punctuation">[</span>methodName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">buring</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>userDefinedMethod<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> userDefinedMethod <span class="token operator">&amp;&amp;</span> <span class="token function">userDefinedMethod</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 处理收集到信息方法</span>
<span class="token keyword">function</span> <span class="token function">buring</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>getMethodName<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">]</span> <span class="token operator">=</span> arguments <span class="token comment">// 获取当前函数名</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;buring&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> arg<span class="token punctuation">,</span> getMethodName<span class="token punctuation">,</span> <span class="token function">getCurrentPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> event <span class="token operator">=</span> arg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  <span class="token comment">// 这里根据实际情况做些事件过滤</span>
  <span class="token comment">// 假设这里只收集 tag 点击的事件</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token operator">&amp;&amp;</span>event<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;tap&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 如果是组件里的事件没有 this.route 属性</span>
    <span class="token comment">// 组件内可以使用 getCurrentPages() 来获取当前页面路径</span>
    <span class="token keyword">let</span> getCurrentPages <span class="token operator">=</span> <span class="token function">getCurrentPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> currentPage <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>route<span class="token operator">||</span>getCurrentPages<span class="token punctuation">[</span>getCurrentPages<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>route
    <span class="token keyword">let</span> target <span class="token operator">=</span> config<span class="token punctuation">[</span>currentPage<span class="token punctuation">]</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">&amp;&amp;</span>target<span class="token punctuation">[</span>getMethodName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 是否命中埋点配置项</span>
       <span class="token comment">// 埋点上传 </span>
       <span class="token keyword">let</span> params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
       target<span class="token punctuation">[</span>getMethodName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            params<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>item<span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
       <span class="token function">upload</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
         <span class="token literal-property property">target</span><span class="token operator">:</span> target<span class="token operator">+</span><span class="token string">&#39;=&gt;&#39;</span> <span class="token operator">+</span> getMethodName<span class="token punctuation">,</span> 
         <span class="token literal-property property">data</span><span class="token operator">:</span> params
       <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>上面的 <code>config</code> 配置完全可以通过接口来获取，这样就可以灵活的收集想到的事件信息了</strong></p><p><strong>这种方式要注意的地方：</strong></p><ul><li><p>这种方式逻辑层的所有的函数都会执行，所以添加 Hook 的时候可以过滤过一些不必要的函数</p></li><li><p>只有页面绑定的函数触发时才会 <code>event</code> 对象，所以当只收集元素的交互埋点时，可以根据 <code>event</code> 对象做下信息的过滤</p></li><li><p>当前例子是通过【页面路径+函数名】的形式来标识埋点的唯一性，但是如果当前页面存在组件及组件跟页面跟包含相同函数的时候，注意要额外做下判断</p></li><li><p>有时候可能会出现有的函数是在运行时添加的，像这种该怎么添加 hook 呢？</p><ul><li><p>给Page对象设置 <code>proxy</code>，监控 <code>set</code> 方法</p></li><li><p>在所有 hook 中监控 Page 属性的数量</p></li><li><p>Page 添加生命周期函数，<code>onLoad</code> 执行完之后给新生成的 <code>func</code> 添加 <code>hook</code></p></li></ul><p>第一种和第二种都存在多次触发的情况，影响性能。只有第三种是一劳永逸的，只需要执行一次就可以了</p></li></ul><p>总的来说这种方式还是比较理想的，只是要注意的地方是触发 Hook 要根据自己实际情况做下过滤处理</p><h3 id="埋点-确实具体元素" tabindex="-1"><a class="header-anchor" href="#埋点-确实具体元素" aria-hidden="true">#</a> 埋点-确实具体元素</h3><p>那么如何判断当前触发的元素就是我们需要埋点的元素呢？</p><p>一、 通过 <code>data-xxx</code> 或 <code>id</code> 属性来判断当前元素是还是要触发埋点的元素，如 <code>e.target.dataset[xxx] === xxx</code>，这种方式的缺点就在于需要开发手动添加这些属性，不够灵活而且也会出现遗漏的问题</p><p>二、 通过当前触发的事件的位置是否在埋点元素区域内</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// js </span>
<span class="token function">elementTracker</span><span class="token punctuation">(</span><span class="token parameter">clickInfo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 需要记录元素的className</span>
  <span class="token keyword">const</span> trackElementName <span class="token operator">=</span> <span class="token string">&#39;.more&#39;</span><span class="token punctuation">;</span>
  <span class="token comment">// 通过元素坐标信息与点击坐标信息，判断是否被点击</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span>trackElementName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span>boundingClientRect<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> isHit <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isClickTrackArea</span><span class="token punctuation">(</span>clickInfo<span class="token punctuation">,</span> item<span class="token punctuation">,</span> res<span class="token punctuation">.</span>scrollOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isHit<span class="token punctuation">,</span> <span class="token string">&#39;isHit&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token doc-comment comment">/**
 * 判断点击是否落在目标元素
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>Object<span class="token punctuation">}</span></span> <span class="token parameter">clickInfo</span> 用户点击坐标
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>Object<span class="token punctuation">}</span></span> <span class="token parameter">boundingClientRect</span> 目标元素信息
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>Object<span class="token punctuation">}</span></span> <span class="token parameter">scrollOffset</span> 页面位置信息
 * <span class="token keyword">@returns</span> <span class="token class-name"><span class="token punctuation">{</span>Boolean<span class="token punctuation">}</span></span> 是否被点击
 */</span>
<span class="token function">isClickTrackArea</span><span class="token punctuation">(</span><span class="token parameter">clickInfo<span class="token punctuation">,</span> boundingClientRect<span class="token punctuation">,</span> scrollOffset</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>boundingClientRect<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> clickInfo<span class="token punctuation">.</span>detail<span class="token punctuation">;</span> <span class="token comment">// 点击的x y坐标</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> top<span class="token punctuation">,</span> height <span class="token punctuation">}</span> <span class="token operator">=</span> boundingClientRect<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> scrollTop <span class="token punctuation">}</span> <span class="token operator">=</span> scrollOffset<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> scrollTop <span class="token operator">+</span> top <span class="token operator">&lt;</span> y <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> scrollTop <span class="token operator">+</span> top <span class="token operator">+</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token doc-comment comment">/**
 * 获取页面元素信息
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>String<span class="token punctuation">}</span></span> <span class="token parameter">element</span> 元素class或者id
 * <span class="token keyword">@returns</span> <span class="token class-name"><span class="token punctuation">{</span>Promise<span class="token punctuation">}</span></span>
 */</span>
<span class="token function">getBoundingClientRect</span> <span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">reslove</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> query <span class="token operator">=</span> wx<span class="token punctuation">.</span><span class="token function">createSelectorQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    query<span class="token punctuation">.</span><span class="token function">selectAll</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">boundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    query<span class="token punctuation">.</span><span class="token function">selectViewport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scrollOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token function">reslove</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">boundingClientRect</span><span class="token operator">:</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token literal-property property">scrollOffset</span><span class="token operator">:</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三、就是上面例子所用的【页面路径+函数名】</p><h3 id="在-uni-app-中使用" tabindex="-1"><a class="header-anchor" href="#在-uni-app-中使用" aria-hidden="true">#</a> 在 Uni-App 中使用</h3><p>在 Uni-App 中使用也是差不多的，在 <code>main.js</code> 中去扩展原生的 <code>Page</code> 和 <code>Component</code> 两个方法，但是也有一些不同的地方：</p><p>uni-app 已经对所以页面方法做了额外的 Hook，所以我们自己的 hook 中，不能直接拿到方法名，拿到的是 uni-app 的 Hook (拿到是 <code>handleEvent</code>、<code>handleLink</code> 之类名字)，好在 uni-app 对于所有的函数调用都添加了 <code>event</code> 参数。<code>event</code> 对于表现为：</p><ul><li><p>这个 <code>event</code>在原生小程序中，只有页面触发的才有 <code>event</code> 对象，在 <code>uni-app</code> 即使是函数调用的函数也会有这个对象，如果当前函数是由页面事件触发的 <code>event.type</code> 跟原生小程序一样指向当前事件类型</p></li><li><p>如果这个函数是另个函数调用而触发的（假如 函数B 调用了 函数A），那么的 函数A 的中 <code>event.type=B</code>，这其实也挺方便</p></li></ul><p>回到正题，那么如何获取到当前触发的函数名呢？经过观察可以使用 <code>event.currentTarget.dataset.eventOpts</code>，理由如下：</p><ul><li><p><code>event.currentTarget</code> 是绑定了函数事件的对象</p></li><li><p><code>dataset.eventOpts</code> 是一个数组，保存了该元素绑定的事件名，假设当前元素同时绑定了 <code>@tap</code> 和 <code>@touchstart</code>。如： <code>&lt;view @tap.stop=&quot;toShowModal(&#39;changePriceShow&#39;)&quot; @touchstart=&quot;toShowModal(&#39;changePriceShow&#39;)&quot;&gt;&lt;/view&gt;</code><br> 当前点击这个元素时，<code>dataset.eventOpts</code> 值为：</p><p><img src="`+v+'" alt=""></p><p>再展开其中一个数组，得到以下信息：</p><p><img src="'+m+`" alt=""></p><p>可以发现触发的事件名、函数名及参数都可以获取</p></li></ul><p>最终获得的函数名的代码为：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">buring</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> event <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token operator">&amp;&amp;</span>event<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;tap&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// console.log(&#39;buring&#39;, this, arguments, getCurrentPages())</span>
    <span class="token keyword">let</span> tagEvent <span class="token operator">=</span> event<span class="token punctuation">.</span>currentTarget<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>eventOpts<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&#39;tap&#39;</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tagEvent<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> methodName <span class="token operator">=</span> tagEvent<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;方法名&#39;</span><span class="token punctuation">,</span> methodName<span class="token punctuation">)</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;参数&#39;</span><span class="token punctuation">,</span> tagEvent<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,34),cn={href:"https://cloud.tencent.com/developer/article/1755182",target:"_blank",rel:"noopener noreferrer"};function ln(un,rn){const a=o("ExternalLinkIcon");return c(),i("div",null,[g,n("h2",h,[f,s(),n("a",y,[s("官方优化建议"),e(a)])]),x,w,j,P,n("ul",null,[n("li",null,[n("p",null,[n("a",_,[s("分包加载"),e(a)])])]),n("li",null,[n("p",null,[n("a",S,[s("分包预下载"),e(a)])])]),n("li",null,[n("p",null,[n("a",O,[s("独立分包"),e(a)])])]),n("li",null,[n("p",null,[n("a",q,[s("分包导步化"),e(a)])])])]),A,M,R,E,D,C,n("p",null,[s("目前小程序打包是会将工程下所有文件都打入代码包内，也就是说，这些没有被实际使用到的库文件和资源也会被打入到代码包里，从而影响到整体代码包的大小。建议使用微信开发者工具提供的「"),n("a",N,[s("代码静态依赖分析"),e(a)]),s("」来分析代码包的文件构成和依赖关系，以此优化代码包大小和内容")]),T,n("p",null,[n("strong",null,[n("a",H,[s("使用按需注入"),e(a)])])]),J,n("p",null,[n("strong",null,[n("a",I,[s("使用用时注入"),e(a)])])]),z,U,Q,n("ul",null,[n("li",null,[n("p",null,[n("a",V,[s("数据预拉取"),e(a)]),s("：能够在小程序冷启动的时候通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完时可以更快地渲染页面，减少用户等待时间，从而提升小程序的打开速度。")])]),n("li",null,[n("p",null,[n("a",B,[s("周期性更新"),e(a)]),s("：在用户未打开小程序的情况下，也能从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间")])])]),L,n("p",null,[s("自基础库版本 2.11.1 起，小程序支持"),n("a",X,[s("初始渲染缓存"),e(a)]),s("，可以在非首次启动时，使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始 "),K,s(" 的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。")]),Z,n("blockquote",null,[n("p",null,[n("a",W,[s("微信小程序之提高应用速度小技巧"),e(a)])])]),G,n("blockquote",null,[n("p",null,[n("a",Y,[s("微信小程序运行流程看这篇就够了"),e(a)]),F,n("a",$,[s("深入解读-微信小程序SDK"),e(a)]),nn,n("a",sn,[s("浅谈小程序运行机制"),e(a)])])]),an,n("p",null,[s("更多的实现细节参考这个 "),n("a",en,[s("xbossdebug"),e(a)]),s(" 的实现")]),n("blockquote",null,[n("p",null,[n("a",pn,[s("小程序异常监控收集"),e(a)])])]),n("blockquote",null,[n("p",null,[n("a",tn,[s("小程序的当下和未来可能 | 崔红保在GMTC 深圳站演讲内容整理"),e(a)])])]),on,n("blockquote",null,[n("p",null,[n("a",cn,[s("小程序可视化实时自动埋点设计"),e(a)])])])])}const kn=t(b,[["render",ln],["__file","微信小程序.html.vue"]]);export{kn as default};
