import{_ as n,o as a,c as s,e}from"./app-quQJY7jk.js";const p={},t=e(`<h1 id="评审" tabindex="-1"><a class="header-anchor" href="#评审" aria-hidden="true">#</a> 评审</h1><p>各位评委好，我叫兰江州，目前在财经中心成本结算组担任前端开发工作师，目前的职级为 8 级，当前评估职级为9级</p><p>接下来我主要会从 性能优化、架构能力、开发语言 这三个方面来举证自己的能</p><h2 id="架构能力-重构" tabindex="-1"><a class="header-anchor" href="#架构能力-重构" aria-hidden="true">#</a> 架构能力-重构</h2><p>接下要举证的是架构能力</p><p>首先要举证的例子是之前对部门的前端模板做了一次重构工作</p><p>重构的背景是因为无论是自己还是部门其它的前端小伙伴在使用这个前端模板的时候都发现并收集了一些问题，这些问题涵盖。。。</p><p>所以就进行了一次重构工作</p><h3 id="菜单权限" tabindex="-1"><a class="header-anchor" href="#菜单权限" aria-hidden="true">#</a> 菜单权限</h3><p>菜单权限之前设计存在的问题在于，菜单的结构与路由结构必需是一致，强耦合的关系，任意一方的修改，另一方也要一起修改</p><p>这也导致前端无法灵活使用路由</p><p>因此重构后最大的改动就是将他们进行解耦，他们的关系只有 code，至于菜单结构的配置与路由配置没有任何的关系，这即方便了双方的配置同时也让前端可以更灵活使用路由</p><h3 id="组件" tabindex="-1"><a class="header-anchor" href="#组件" aria-hidden="true">#</a> 组件</h3><p>以独立性为原则重构了组件，比如之前的路由历史页签组织依赖 vuex 进行管理，我就他们进行解耦的工作，还有一些通用组件可能需要使用到请求的功能，为了独立性可能自己封闭了请求方式 这种方式有一个问题就是请求的行为很难项目本身的请求保持一致</p><p>因此我改成组件只需要约定请求返回值的格式，在注册的组件的传入项目本身的请求方法给组件进行使用，这样即保持组件独立性，即省去这块的额外封装，同时行为又能与项目行为保存一致</p><p>并以严格按通用组件、业务组件、应用组件进行划分</p><p>然后就是重新封装了请求方法，添加了防重复请求、支持快捷添加loading，loading 的处理是以单例模式设计的，以此来控制loading 的生命周期</p><p>之前一次请求致需要22行代码，新的请求方式只需要13行代码</p><p>然后就是删除了很无用的代码和模块，毕竟 More less more fast</p><p>以物以类聚、向下划分主干与支干的的规则来管理文件和组织代码，避免出现的臃肿的文件</p><h2 id="开发语言-requestidlecallback" tabindex="-1"><a class="header-anchor" href="#开发语言-requestidlecallback" aria-hidden="true">#</a> 开发语言-requestIdleCallback</h2><p>最后是开发语言能力的举证</p><p>第一个例子是 JS单线程的原因，对体量大的数据处理会产生阻塞问题，比如项目中加载一万多条的数据，并需要遍历他们进行加工和显示就需等待 7.5s 左右</p><h2 id="开发语言-配置化表格与表单" tabindex="-1"><a class="header-anchor" href="#开发语言-配置化表格与表单" aria-hidden="true">#</a> 开发语言-配置化表格与表单</h2><ol><li>后台系统常见的表单与表格功能和交互都是相似的，但每次开发都需要重新编写相同的代码逻辑</li><li>而且表单与表格的实现基本占用了模板部分一半的代码量</li></ol><p>为了更加方便和快速和开发这部分的功能，我封装配置化表单与表格组件，通过配置（JSON）的形式来自动渲染出表格与表单</p><h2 id="性能优化-spreadjs" tabindex="-1"><a class="header-anchor" href="#性能优化-spreadjs" aria-hidden="true">#</a> 性能优化 - spreadJS</h2><p>首先是性能优化方面</p><p>第一个要举证的例子是目前正在参与的集团预算编制项目CBM，它是用于解决集团业务到财务的编制问题，因为使用群体需要使用 excel 进行数据管理， 之前是使用控件的方式进行使用，使用功能复杂，成本高，因此项目引入SpreadJS，一个 web excel的JS库 ，在使用的过程中发现数据加载存在非常严重的性能问题，上百条数据超过9秒，上千条数据则会导致页面崩溃</p><p>针对这种问题，当时我首先是使用谷歌的调试工具 Performance 查看一下数据的加载到显示期间代码的执行情况，最终通过输出结果定位到了两处问题：</p><ol><li><p>首先是根据底部面板发现一个 defineReactive 这个函数，他占用了 20% 的执行时间，这个项目是用 vue 开发的，结合 Vue 的响应式原理，可以判定组件 data 出现了非常大的属性</p></li><li><p>第二点结合火焰图可以发现大量的时间是在处理表格的样式</p></li></ol><h3 id="解决问题" tabindex="-1"><a class="header-anchor" href="#解决问题" aria-hidden="true">#</a> 解决问题</h3><p>定位到问题之后就可以针对性进行优化了</p><p>首先 defineReactive 耗时问题：</p><p>解决方法是将体量大的属性移出 data 或者冻结这些属性，减少 vue 对 data 的初始化工作</p><p>对于 spreadJS 样式设置的问题，我当时的解决方式是从官方文档中查阅样式设置的所有方法，结合论坛及自己的尝试，总结出设置样式方法的性能优劣情况： 从高到低分别是 全局默认样式 &gt; 行/列样式设置 &gt; Range局部样式设置 &gt; 单元格样式设置</p><p>然后将现有样式设置的处理按上述顺序进行优化</p><p>优化后在相同数据情况下，数据加载的时候从 9.3s 缩减至 0.4s</p><h2 id="性能优化-长列表" tabindex="-1"><a class="header-anchor" href="#性能优化-长列表" aria-hidden="true">#</a> 性能优化 - 长列表</h2><p>第二个要举证的优化例子是项目有些地方的下拉选择的数据比较大，每次打这些选项都能感觉到页面很卡顿，也是结合 performance，可以发现在显示下拉选项的过程中,CPU一直在做渲染工作</p><p>渲染过程大约要执行 2秒左右</p><p>我当然解决方案是重新编写 select 组件， 采用虚拟滚动来显示列表选项，以此来达到控制 Dom 节点渲染数量的目的</p><p>优化可以看到 下拉选项的节点不再全部展示，显示的时候 从原来 2s 直接缩短至 64ms</p><h2 id="岗位工作目标及对应关键举措" tabindex="-1"><a class="header-anchor" href="#岗位工作目标及对应关键举措" aria-hidden="true">#</a> 岗位工作目标及对应关键举措</h2><p>能力举证的例子就介绍完了，接下是我短期内我的工作目标是：</p><ol><li><p>全面完成预算项目的优化工作</p></li><li><p>目前团队正在使用 qiankun 框架来实现微前端，我希望小伙伴们不仅仅只会使用，因此近期会做一次相关知识点的分享，主题为《qiankun 实现原理》</p></li></ol><p>自己重点提升的能力是深入到服务层</p><p>关键举措</p><ol><li><p>优化工作：优化的过程会不断探索优化方法，尽量使用最优的方案来解决问题</p></li><li><p>服务层：一方面业余时间多看看相关知识点、另一方面结合工作多与后台同学请教</p></li></ol><h2 id="架构能力-q-a" tabindex="-1"><a class="header-anchor" href="#架构能力-q-a" aria-hidden="true">#</a> 架构能力 Q&amp;A</h2><h3 id="防重复请求思路" tabindex="-1"><a class="header-anchor" href="#防重复请求思路" aria-hidden="true">#</a> 防重复请求思路</h3><ul><li><p>使用url method 参数 作为每一个请求的唯一标识</p></li><li><p>如果标识重复出现了，说明重复发起了请求，则通过 CancelToken 直接取消当前请求</p></li></ul><h3 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h3><ul><li><p>单例模式</p></li><li><p>构造函数模式</p></li><li><p>外观模式</p></li><li><p>观察者模式</p></li><li><p>发布订阅者模式</p></li><li><p>建造者模式； 复杂功能内置处理，对于使用者来说只需要通过简的配置就可以得到所需的东西，不需要关注实现细节，比如请求封闭</p></li><li><p>装饰器模式</p></li></ul><p><strong>观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心</strong></p><ul><li>工厂模式：模板？</li></ul><h3 id="如果解决-url-同步问题" tabindex="-1"><a class="header-anchor" href="#如果解决-url-同步问题" aria-hidden="true">#</a> 如果解决 url 同步问题</h3><ol><li><p>iframe 项目监听 url 变化，通过 postMessage 通知父项目</p></li><li><p>history 模式下 pushState 和placeState是 是不是能触发 onpopstate 事件的，通信重写来解决</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> <span class="token keyword">const</span> <span class="token function-variable function">bindEventListener</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> historyEvent <span class="token operator">=</span> history<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">;</span>
         <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token keyword">const</span> newEvent <span class="token operator">=</span> <span class="token function">historyEvent</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token keyword">const</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
             e<span class="token punctuation">.</span>arguments <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
             window<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">return</span> newEvent<span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 history<span class="token punctuation">.</span>pushState <span class="token operator">=</span> <span class="token function">bindEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;pushState&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 history<span class="token punctuation">.</span>replaceState <span class="token operator">=</span> <span class="token function">bindEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;replaceState&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="render-方法是否有性能问题" tabindex="-1"><a class="header-anchor" href="#render-方法是否有性能问题" aria-hidden="true">#</a> render 方法是否有性能问题</h3><p>vue 模板本身就是会编译成 render</p><h3 id="render-里的-h-方法返回的是什么" tabindex="-1"><a class="header-anchor" href="#render-里的-h-方法返回的是什么" aria-hidden="true">#</a> render 里的 h 方法返回的是什么</h3><p>虚拟 Dom</p><h3 id="createelement" tabindex="-1"><a class="header-anchor" href="#createelement" aria-hidden="true">#</a> createElement ?</h3><p><code>createElement</code>接收参数如下：</p><ul><li><p><code>tag</code>: {String | Object | Function}表示一个 HTML 标签名、组件选项对象</p></li><li><p><code>data</code>: 可选参数，表示 <code>VNode</code> 的数据，完整的数据对象如下</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>  <span class="token punctuation">{</span>
    <span class="token comment">// 和\`v-bind:class\`一样的 API</span>
    <span class="token string-property property">&#39;class&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 和\`v-bind:style\`一样的 API</span>
    <span class="token literal-property property">style</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">fontSize</span><span class="token operator">:</span> <span class="token string">&#39;14px&#39;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 正常的 HTML 特性</span>
    <span class="token literal-property property">attrs</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 组件 props</span>
    <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">myProp</span><span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// DOM 属性</span>
    <span class="token literal-property property">domProps</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">innerHTML</span><span class="token operator">:</span> <span class="token string">&#39;baz&#39;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 事件监听器基于 &quot;on&quot;</span>
    <span class="token comment">// 所以不再支持如 v-on:keyup.enter 修饰器</span>
    <span class="token comment">// 需要手动匹配 keyCode。</span>
    <span class="token literal-property property">on</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">click</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clickHandler
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 仅对于组件，用于监听原生事件，而不是组件使用 vm.$emit 触发的事件。</span>
    <span class="token literal-property property">nativeOn</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">click</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nativeClickHandler
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 自定义指令. 注意事项：不能对绑定的旧值设值</span>
    <span class="token comment">// Vue 会为您持续追踨</span>
    <span class="token literal-property property">directives</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;my-custom-directive&#39;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">&#39;2&#39;</span>
        <span class="token literal-property property">expression</span><span class="token operator">:</span> <span class="token string">&#39;1 + 1&#39;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">arg</span><span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">modifiers</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// 如果子组件有定义 slot 的名称</span>
    <span class="token literal-property property">slot</span><span class="token operator">:</span> <span class="token string">&#39;name-of-slot&#39;</span>
    <span class="token comment">// 其他特殊顶层属性</span>
    <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">&#39;myKey&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">ref</span><span class="token operator">:</span> <span class="token string">&#39;myRef&#39;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>children</code>：{String | Array} 表示子节点</p></li></ul><p>这里着重了解一下 <code>createComponent</code> 第一个参数 <code>tag</code> ， <code>tag</code> 可以有的类型以及对应的内部处理大致如下</p><ul><li><p>如果是 <code>String</code> 类型</p><ul><li><p>选判断如果是内置的一些节点，则直接创建一个普通 <code>VNode</code></p></li><li><p>如果是为已注册的组件名，则通过 <code>createComponent</code> 创建一个组件类型的 <code>VNode</code></p></li></ul></li><li><p>如果是 <code>tag </code>一个 Component 类型，则直接调用 <code>createComponent</code> 创建一个组件类型的 <code>VNode</code> 节点</p></li><li><p>其它值暂不讨论</p></li></ul><h2 id="开发语言-q-a" tabindex="-1"><a class="header-anchor" href="#开发语言-q-a" aria-hidden="true">#</a> 开发语言 Q&amp;A</h2><p><strong>requestIdleCallback缺陷</strong></p><ul><li><p>兼容性一般：如 IE、Safari 不支持</p></li><li><p>requestIdleCallback FPS只有20，常规是 60，流畅度也是低于常规</p></li></ul><p><strong>想要实现requestIdleCallback的处理，有2个点需要解决:</strong></p><ul><li><p>如何判断一帧是否有空闲？</p><p>requestAnimationFrame 计算一帧到期时间点</p><p>估算一帧结束时间：<code>const deadline = raf + 1000/60;</code></p></li><li><p>下一次宏任务判断时间是否有超过过期时间 <code>deadlineTime - performance.now()</code></p><p>如果时间则时间任务</p></li></ul><p><strong>为什么使用 MessageChannel 执行宏任务？</strong></p><p>因为 setTimeout 有阈值，4ms</p><h3 id="可以用-settimeout-么" tabindex="-1"><a class="header-anchor" href="#可以用-settimeout-么" aria-hidden="true">#</a> 可以用 setTimeout 么？</h3><p>可以！ 但没有 requestIdleCallback 好</p><p>serTimeout 只是粗暴得将任务塞到下一次宏任务执行，会跟下一次宏任务里的任务一起占用执行时间</p><p>而requestIdleCallback更温和点，只在一帧的空闲时间去执行</p><h2 id="配置化表单的特点" tabindex="-1"><a class="header-anchor" href="#配置化表单的特点" aria-hidden="true">#</a> 配置化表单的特点</h2><ol><li><p>使用 render 方法代替 if/else</p></li><li><p>支持个性化元素</p></li><li><p>封装了交互，即使使用了 slot 来展示，也可交互</p></li></ol><h2 id="性能优化q-a" tabindex="-1"><a class="header-anchor" href="#性能优化q-a" aria-hidden="true">#</a> 性能优化Q&amp;A</h2><h3 id="响应式原理" tabindex="-1"><a class="header-anchor" href="#响应式原理" aria-hidden="true">#</a> 响应式原理？</h3><p>Vue 响应式原理有三个要素组合：侦听器、依赖收集器、Watcher 事件</p><p>侦听器是通过遍历 data 属性然后使用 defineProperty 劫持属性的 set/getter 方法</p><p>然后每个属性还会实例一个 依赖收集器，这个收集器是一种发布-订阅者模式</p><p>依赖收集器具体收集的就是 Watcher 事件</p><p>这个Watcher 事件就是具体渲染组件功能的一个对象</p><p>整个流程就是组件在首次渲染的时候，会该跟 data 属性，被 get 劫持，然后收集当前的 Watcher事件，这一步就完成事件的收集功能</p><p>之后当修改 data 属性时，被 set 劫持，然后从当前派发当前收集到 watcher ，进行组件更新</p><h3 id="defindproperty-的缺点" tabindex="-1"><a class="header-anchor" href="#defindproperty-的缺点" aria-hidden="true">#</a> defindProperty 的缺点</h3><p>无法监听数组方法的变化、通过索引修改值也无法监测到</p><p>vue是通过重写数据方法来实现监听功能</p><p>索引的修改没有办法，只能通过提供的 $set 方法来进行操作</p><h3 id="重写方法和-set-具体做了什么" tabindex="-1"><a class="header-anchor" href="#重写方法和-set-具体做了什么" aria-hidden="true">#</a> 重写方法和 $set 具体做了什么？</h3><p>以数组为例，在处理data属性的时候，都会给当前属性额外添加一个 __ob__属性，这个__ob__是指向当前属性的依赖收集器</p><h3 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3" aria-hidden="true">#</a> Vue3？</h3><p>Vue 在初始化的时候使用 proxy 方法代理，关于收集器两个版本的区别</p><p>Vue2.0 会为每个属性实例化一个事件收集器 Dep</p><p>Vue3.0 则通过全局变量 const targetMap = new WeakMap(); 来做事件收集容器，targetMap 的 key 是代理对象，value 是 depsMap(一个收集事件容器的容器)</p><p>depsMap 是 new Map() 结构，代理对象的每个属性收集的事件将存储在这个 depsMap 中，所以找属性收集的事件时，先根据这个属性所属对象从 targetMap 找 depsMap, 在根据具体属性从 depsMap 找事件</p><p>在组件渲染的时候，会生成一个 effect 方法，并将当前 effect 保存到全局 activeEffect中，之后在执行渲染操作的时候会读取 data 的属性， 并被 get 劫持，get 方法中将保存在全局的 activeEffect 收集到 depsMap 中</p><p>之后当 data 属性被更改时，会被 set 劫持，从 depsMap 取出 effect 并执行</p><h3 id="object-freeze" tabindex="-1"><a class="header-anchor" href="#object-freeze" aria-hidden="true">#</a> Object.freeze</h3><ul><li><p>属性描述符：enumerable、configurable</p></li><li><p>数据描述符：value、writable</p></li><li><p>存储描述符：get、 set</p></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">prop</span><span class="token operator">:</span> <span class="token number">42</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&#39;prop&#39;</span><span class="token punctuation">)</span>

<span class="token comment">// {value: 42, writable: false, enumerable: true, configurable: false}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="object-freeze-属性值是对象-可以修改么" tabindex="-1"><a class="header-anchor" href="#object-freeze-属性值是对象-可以修改么" aria-hidden="true">#</a> Object.freeze 属性值是对象，可以修改么</h3><p>可以</p><h3 id="object-freeze-对数组有效么" tabindex="-1"><a class="header-anchor" href="#object-freeze-对数组有效么" aria-hidden="true">#</a> Object.freeze 对数组有效么</h3><p>有</p><h3 id="freeze-和-seal-区别" tabindex="-1"><a class="header-anchor" href="#freeze-和-seal-区别" aria-hidden="true">#</a> freeze 和 seal 区别</h3><p>使用Object.freeze()冻结的对象中的现有属性值是不可变的。用Object.seal()密封的对象可以改变其现有属性值。</p><ul><li>seal 无法新增或修改属性</li></ul><h3 id="虚拟滚动实现思想" tabindex="-1"><a class="header-anchor" href="#虚拟滚动实现思想" aria-hidden="true">#</a> 虚拟滚动实现思想</h3><p>外层定义一个固定高度的 div</p><p>内层定义一个所有数据高度的容器</p><p>监听外层滚动事情，通过滚动条的高度来判断当前滚动位置应显示的数据位置</p><p>然后显示数据那层再通过 transform 偏移量保存与 scrollTop 一致</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>  <span class="token function">scroll</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">{</span>scrollTop<span class="token punctuation">}</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>target
    <span class="token keyword">let</span> ind <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>scrollTop <span class="token operator">/</span> itemHeight<span class="token punctuation">)</span> <span class="token comment">// 从第几条数据开始显示</span>
    ind <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ind<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dataLen <span class="token operator">-</span> visibilityNum<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> ind
    <span class="token comment">// Math.abc(...) 是滚动到底部时，列表应该所在的偏移量</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>top <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>scrollTop<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>scrollTop <span class="token operator">-</span> <span class="token punctuation">(</span>visibilityNum <span class="token operator">*</span> itemHeight <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>boxHeight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="如何虚拟滚动元素高度都不致呢" tabindex="-1"><a class="header-anchor" href="#如何虚拟滚动元素高度都不致呢" aria-hidden="true">#</a> 如何虚拟滚动元素高度都不致呢</h3><p>中间滚动过程：假可见容易高度为 10，那么列表容器假设为 50px,顶部还一个空元素用于撑开顶部没有渲染出来的列表高度， 此时可视区域为 20到30 数据，首属各有20条数据，这个数据都是估算数据，部除了可视区域的显示，顶部和渲染区域能足够用于滚动却可，那么在滚动的过程中，以一个可见视图高度为一个单位，比如我滚动到了20，此时削掉头部10条数据，顶空间DVI就增加削掉元素的高度各，向上滚动时也是同理</p><p>一开始滚动的时候，就判断阙值</p><p>结尾滚动的时候，当前列表已经把最后的数据列上去时，此时可以判断最底离顶的高度，调整顶部空白高度，让空白DIV + 渲染列表的高度等于最后一个元素到顶的高度</p><h3 id="性能指标" tabindex="-1"><a class="header-anchor" href="#性能指标" aria-hidden="true">#</a> 性能指标</h3><ul><li><p>FCP：首次内容绘制</p></li><li><p>LCP：最大内容绘制</p></li><li><p>FID (First Input Delay)：首次输入延迟，首次输入延迟</p></li></ul><h3 id="重排会产生比重绘更大的开销" tabindex="-1"><a class="header-anchor" href="#重排会产生比重绘更大的开销" aria-hidden="true">#</a> 重排会产生比重绘更大的开销</h3><h2 id="关于财经建设这块" tabindex="-1"><a class="header-anchor" href="#关于财经建设这块" aria-hidden="true">#</a> 关于财经建设这块</h2><p>我们这份开发的根本是要开发一款程序，这个程序运行的质量、可行性、体验才是我们追求的最终目的 然后再往前推一点则是考虑 更高效开发过程 代码管理 等</p><p>而所有工具及技术 及流程都是服务于其中某一环节的</p><p>并不是为了用而用，而是为解决某类问题才去用</p><p>我入职到目前八个月左右，就我目前所想，用不到这些技术，反而这些技术增加了开发的复杂度</p><p>我个人更倾向于先关注于最基本的东西。 比如代码本身，我更希望让团队都具有一些共识，就是把自己负责的项目 当做自己的作品一样去认真对待，这些不在于要使用多少牛B的技术，而尽量去完善自己写的代码和功能， 把代码写漂亮点。在思考代码优化和性能优化的过程中去自然而然引用一些技术来解决问题</p><p>而不是盲目追求或使用某类技术</p>`,132),o=[t];function i(l,r){return a(),s("div",null,o)}const d=n(p,[["render",i],["__file","评审.html.vue"]]);export{d as default};
