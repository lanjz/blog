import{_ as l,o as i,c as p,e}from"./app-usrflJuT.js";const o={},c=e('<h1 id="组件设计的基本原则" tabindex="-1"><a class="header-anchor" href="#组件设计的基本原则" aria-hidden="true">#</a> 组件设计的基本原则</h1><ul><li><p>单一职责</p><ul><li><p>组件是否符合只实现一个职责，并且只有一个改变状态的理由</p></li><li><p>单一职责可以保证组件是最细的粒度，且有利于复用。但太细的粒度有时又会造成组件的碎片化</p></li><li><p>单一职责组件要建立在可复用的基础上，对于不可复用的单一职责组件，我们仅仅作为独立组件的内部组件即可</p></li></ul></li><li><p>通用性</p><ul><li>组件开发要服务于业务，为了更好的复用，又要从业务中抽离</li></ul></li><li><p>封装</p><ul><li><p>良好的组件封装应该隐藏内部细节和实现意义，并通过<code>props</code>来控制行为和输出</p></li><li><p>减少访问全局变量：因为它们打破了封装，创造了不可预测的行为，并且使测试变得困难。 可以将全局变量作为组件的<code>props</code>，而不是直接引用</p></li></ul></li><li><p>组合</p><ul><li><p>具有多个功能的组件，应该转换为多个小组件</p></li><li><p>单一责任原则描述了如何将需求拆分为组件，封装描述了如何组织这些组件，组合描述了如何将整个系统粘合在一起</p></li></ul></li><li><p>纯组件和非纯组件</p><ul><li><p>非纯组件有显示的副作用，我们要尽量隔离非纯代码</p></li><li><p>将全局变量作为<code>props</code>传递给组件，而非将其注入到组件的作用域中</p></li><li><p>将网络请求和组件渲染分离，只将数据传递给组件，保证组件职责的单一性，也能将非纯代码从组件中隔离</p></li></ul></li><li><p>可测试</p><ul><li><p>测试不仅仅是自动检测错误，更是检测组件的逻辑</p></li><li><p>如果一个组件测试不易于测试，很大可能是你的组件设计存在问题</p></li></ul></li><li><p>富有意义</p><ul><li>有意义的函数、变量命名，可以让代码具有良好的可读性</li></ul></li></ul>',2),_=[c];function t(u,r){return i(),p("div",null,_)}const s=l(o,[["render",t],["__file","组件设计的基本原则.html.vue"]]);export{s as default};
