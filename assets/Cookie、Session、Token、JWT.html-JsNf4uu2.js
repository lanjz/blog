import{_ as e,o as i,c as o,e as s}from"./app-ly5YjvTc.js";const l={},n=s('<h1 id="cookie-session-token-jwt" tabindex="-1"><a class="header-anchor" href="#cookie-session-token-jwt" aria-hidden="true">#</a> Cookie,Session,Token,JWT</h1><h2 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie" aria-hidden="true">#</a> Cookie</h2><ul><li><p>存储位置：Cookie数据存储在客户端（用户的浏览器）上。</p></li><li><p>数据传输：每次向同一服务器发送请求时，Cookie数据都会自动加在请求头中发送给服务器。</p></li><li><p>容量限制：Cookie有大小限制（每个域名下大约为4KB），并且浏览器限制每个域名下的Cookie数量。</p></li><li><p>安全性：由于存储在客户端，容易被用户删除和篡改，因此安全性相对较低。敏感信息不应存储在Cookie中。</p></li><li><p>生命周期：Cookie可以设置过期时间。如果不设置，生命周期默认为浏览器会话期间；设置了过期时间后，即使关闭浏览器，Cookie也会保留到指定的时间。</p></li></ul><h2 id="session" tabindex="-1"><a class="header-anchor" href="#session" aria-hidden="true">#</a> session</h2><ul><li><p>存储位置：Session数据存储在服务器上。</p></li><li><p>数据传输：服务器为每个用户的会话分配一个唯一的Session ID，而Session ID通常通过Cookie在客户端和服务器之间传递。用户的所有请求都会携带这个Session ID，服务器据此识别用户。</p></li><li><p>容量限制：Session理论上没有大小限制，可以存储较大量的数据。</p></li><li><p>安全性：由于存储在服务器上，安全性相对较高。但需要正确处理Session ID的传输，防止会话劫持等安全问题。</p></li><li><p>生命周期：Session的生命周期通常由服务器控制，可以基于一段时间的不活动自动过期，或者由服务器端的逻辑显式销毁。</p></li></ul><h3 id="session-认证流程" tabindex="-1"><a class="header-anchor" href="#session-认证流程" aria-hidden="true">#</a> session 认证流程</h3><ul><li><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session, 并生成一个<code>sessionId</code></p></li><li><p>将<code>sessionId</code> 保存 <code>cookie</code> 中并返回给浏览器</p></li><li><p>当用户第二次访问服务器的时候，会自动携带设置的 <code>cookie</code> 传给服务器</p></li><li><p>服务器接收到客户端传回的 <code>cookie</code> 获取到其中的 <code>sessionId</code>,再根据 <code>SessionID</code> 查找对应的 <code>Session</code> 信息进行身份验证</p></li></ul><h3 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点" aria-hidden="true">#</a> 注意点</h3><ul><li><p>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</p></li><li><p>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</p></li></ul><h3 id="cookie-和-session-的区别" tabindex="-1"><a class="header-anchor" href="#cookie-和-session-的区别" aria-hidden="true">#</a> Cookie 和 Session 的区别</h3><ul><li><p>存储位置：Cookie存储在客户端，Session存储在服务器。</p></li><li><p>保存的数据格式与大小也不同</p></li><li><p>安全性：Session比Cookie安全，因为数据存储在服务器端。</p></li><li><p>生命周期管理：Cookie的生命周期可以由客户端控制或定义，Session的生命周期由服务器管理。</p></li><li><p>性能考量：每次HTTP请求都会携带Cookie，可能会影响性能；而Session需要服务器持续跟踪状态，也会消耗服务器资源。</p></li><li><p>用途差异：Cookie常用于保存用户偏好、跟踪用户行为；Session更适合存储敏感信息、用户登录状态等。</p></li></ul><h2 id="token" tabindex="-1"><a class="header-anchor" href="#token" aria-hidden="true">#</a> Token</h2><p>Token是一个广义的概念，它代表了一个系统生成的字符串，用于标识用户的登录会话或进行身份验证。Token可以采取任何格式，不限于特定的数据结构</p><p>一般Token由以下元素组：</p><ul><li><p>uid:用户唯一的身份标识</p></li><li><p>time：当前时间的时间戳</p></li><li><p>sign:签名</p></li></ul><p>Token的特点：</p><ul><li><p>服务端无状态化，可扩展性好</p></li><li><p>支持移动端设备</p></li><li><p>支持跨程序调用</p></li></ul><p>token 的身份验证流程：</p><ul><li><p>客户端使用用户名跟密码请求登录</p></li><li><p>服务端收到请求，去验证用户名与密码</p></li><li><p>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</p></li><li><p>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</p></li><li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</p></li><li><p>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</p></li><li><p>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</p></li><li><p>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</p></li><li><p>token 完全由应用管理，所以它可以避开同源策略</p></li></ul><h2 id="refresh-token" tabindex="-1"><a class="header-anchor" href="#refresh-token" aria-hidden="true">#</a> Refresh Token</h2><p>Refresh Token是在现代身份验证协议中使用的一个概念，主要用于在用户的访问令牌（Access Token）过期后，安全地获取新的访问令牌，而无需用户再次登录。它是OAuth 2.0和OpenID Connect等身份验证框架中的一个重要组成部分</p><h3 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h3><p>在使用Refresh Token的身份验证流程中，当用户成功登录后，身份验证服务器会同时返回一个访问令牌（Access Token）和一个刷新令牌（Refresh Token）：</p><ul><li><p>访问令牌（Access Token）：用于访问受保护的资源，如API调用。访问令牌具有较短的有效期，通常设定为几分钟到几小时不等。</p></li><li><p>刷新令牌（Refresh Token）：用于在访问令牌过期后获取新的访问令牌。刷新令牌具有较长的有效期，通常比访问令牌长得多。</p></li></ul><p>当访问令牌过期后，应用可以使用刷新令牌向身份验证服务器请求一个新的访问令牌。这个过程可以在用户不知情的情况下自动进行，从而提供无缝的用户体验。一旦新的访问令牌被颁发，旧的访问令牌通常会被废弃。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ul><li><p>提高安全性：由于访问令牌具有较短的有效期，即使被泄露，其潜在的风险也相对较低。刷新令牌虽然有效期更长，但仅用于与身份验证服务器通信，不用于访问受保护资源。</p></li><li><p>提升用户体验：用户无需频繁登录，即可保持长时间的会话，尤其适用于移动应用和单页应用（SPA）。</p></li></ul><h3 id="安全注意事项" tabindex="-1"><a class="header-anchor" href="#安全注意事项" aria-hidden="true">#</a> 安全注意事项</h3><ul><li><p>保护刷新令牌：由于刷新令牌可以用来获取新的访问令牌，因此需要确保其安全性，避免泄露。</p></li><li><p>令牌撤销：系统应支持撤销刷新令牌的功能，以应对刷新令牌被泄露或用户登出的情况。</p></li><li><p>限制使用范围：最好限制刷新令牌的使用范围，比如只能从特定的设备或IP地址使用刷新令牌获取新的访问令牌。</p></li></ul><h2 id="jwt" tabindex="-1"><a class="header-anchor" href="#jwt" aria-hidden="true">#</a> JWT</h2><p>JWT是Token的一种实现方式</p><p>JWT 认证流程：</p><ul><li><p>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</p></li><li><p>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</p></li><li><p>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样</p><p>Authorization: Bearer复制代码</p></li><li><p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</p></li><li><p>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库需要</p></li><li><p>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</p></li></ul><h3 id="注意点-1" tabindex="-1"><a class="header-anchor" href="#注意点-1" aria-hidden="true">#</a> 注意点</h3><ul><li><p>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</p></li><li><p>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p></li><li><p>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</p></li></ul><h2 id="jwt-和-session-的区别" tabindex="-1"><a class="header-anchor" href="#jwt-和-session-的区别" aria-hidden="true">#</a> JWT 和 session 的区别</h2><h3 id="session-1" tabindex="-1"><a class="header-anchor" href="#session-1" aria-hidden="true">#</a> Session</h3><ul><li><p>会话状态：Session是有状态的，需要在服务器上存储会话数据。JWT是无状态的，认证信息包含在Token中，并由客户端保存。</p></li><li><p>跨域认证：JWT更适合用于微服务架构和分布式系统中的跨域认证，因为它不依赖于单一的服务器来保存会话信息。</p></li><li><p>性能考量：使用Session可能会随着用户数量的增加而增加服务器的存储压力。而JWT则将存储负担转移到了客户端，减轻了服务器的压力。</p></li><li><p>安全策略：两种技术都需要采取措施保护用户会话不被劫持。对于Session，需要保护Session ID的安全；对于JWT，需要确保Token的安全传输和存储。</p></li></ul><h2 id="jwt-1" tabindex="-1"><a class="header-anchor" href="#jwt-1" aria-hidden="true">#</a> JWT</h2><ul><li><p>存储位置：JWT是一个包含了认证信息的JSON对象，经过签名后安全地在客户端和服务器间传输。JWT可以存储在客户端的LocalStorage或SessionStorage中，并在每次请求时通过HTTP头部发送给服务器。</p></li><li><p>安全性：JWT自身包含验证信息，因此无需在服务器上保存会话状态，这减少了服务器被攻击的风险。但是，如果JWT被截获，攻击者也可能冒充用户，因此安全地传输和存储JWT非常重要。</p></li><li><p>可扩展性：JWT更适用于分布式系统。由于不需要在服务器上存储会话信息，它支持无状态和跨域认证，这使得扩展应用程序变得更容易。</p></li></ul>',40),a=[n];function p(h,r){return i(),o("div",null,a)}const t=e(l,[["render",p],["__file","Cookie、Session、Token、JWT.html.vue"]]);export{t as default};
