import{_ as e,o as a,c as o,e as t}from"./app-kv3zS8h1.js";const c={},d=t(`<h1 id="吱不吱" tabindex="-1"><a class="header-anchor" href="#吱不吱" aria-hidden="true">#</a> 吱不吱</h1><h2 id="react-事件机制" tabindex="-1"><a class="header-anchor" href="#react-事件机制" aria-hidden="true">#</a> React 事件机制</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>点我<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 <code>document</code> 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。 另外冒泡到 <code>document</code> 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 <code>event.stopPropagation</code> 是无效的，而应该调用 <code>event.preventDefault</code></p><p>实现合成事件的目的如下：</p><ul><li><p>合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力</p></li><li><p>对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象</p></li></ul><p>在React底层，主要对合成事件做了两件事：</p><ul><li><p>事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。</p></li><li><p>自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件</p></li></ul><p><img src="https://juejin.cn/post/6909271104440205326" alt="React 事件系统工作原理"></p><h2 id="react-中-key-的作用是什么" tabindex="-1"><a class="header-anchor" href="#react-中-key-的作用是什么" aria-hidden="true">#</a> React 中 key 的作用是什么？</h2><p><code>key</code>的作用更准确的进行 <code>diff</code>算法，React 还需要借助 <code>Key</code> 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 <code>Key</code> 的重要性</p><p>没有<code>key</code>时，在判断新旧地点变化时容易产场就地复用的情况</p><h2 id="调用-setstate-之后发生了什么" tabindex="-1"><a class="header-anchor" href="#调用-setstate-之后发生了什么" aria-hidden="true">#</a> 调用 setState 之后发生了什么？</h2><ol><li><p>将传入的参数与当前的状态合并，然后触发所谓的调和过程（Reconciliation）</p></li><li><p>根据当前的状态构建React元素树</p></li><li><p>在得到元素树，与旧的元素树做节点对比，然后根据差异对界面进行最小化重渲染</p></li><li><p>在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p></li></ol><h2 id="react-生命周期函数" tabindex="-1"><a class="header-anchor" href="#react-生命周期函数" aria-hidden="true">#</a> react 生命周期函数</h2><p><strong>挂载</strong></p><ul><li><p><code>constructor()</code></p><ul><li><p>通过给 <code>this.state</code> 赋值对象来初始化内部 <code>state</code></p></li><li><p>为事件处理函数绑定实例</p></li></ul></li><li><p><code>static getDerivedStateFromProps()</code></p></li><li><p><code>render()</code></p></li><li><p><code>componentDidMount</code></p></li></ul><p><strong>更新</strong></p><ul><li><p><code>static getDerivedStateFromProps()</code></p></li><li><p><code>shouldComponentUpdate(nextProps, nextState)</code></p><p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 <code>state</code> 或 <code>props</code> 更改的影响</p></li><li><p><code>render()</code></p></li><li><p><code>getSnapshotBeforeUpdate()</code></p></li><li><p><code>componetDidUpdate(prevProps, prevState, snapshot)</code>: 会在更新后会被立即调用。首次渲染不会执行此方法。</p></li></ul><p><strong>卸载</strong></p><ul><li><code>componentWillUnMount()</code>：会在组件卸载及销毁之前直接调用</li></ul><h2 id="shouldcomponentupdate-是做什么的" tabindex="-1"><a class="header-anchor" href="#shouldcomponentupdate-是做什么的" aria-hidden="true">#</a> shouldComponentUpdate 是做什么的</h2><p>当 <code>props</code> 或 <code>state</code> 发生变化时，<code>shouldComponentUpdate()</code> 会在渲染执行之前被调用。返回值默认为 true。 如果返回<code>false</code>，则不会执行 <code>render</code>方法进行 DOM 更新 首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。</p><p>为什么虚拟 dom 会提高性能</p><h2 id="react-性能优化是哪个周期函数" tabindex="-1"><a class="header-anchor" href="#react-性能优化是哪个周期函数" aria-hidden="true">#</a> react 性能优化是哪个周期函数</h2><p><code>shouldComponentUpdate()</code></p><h2 id="react-diff-优化原理" tabindex="-1"><a class="header-anchor" href="#react-diff-优化原理" aria-hidden="true">#</a> react diff 优化原理</h2><ul><li><p>把树形结构按照层级分解，只比较同级元素</p></li><li><p>给列表结构的每个单元添加唯一的 key 属性，方便比较</p></li><li><p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p></li><li><p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p></li><li><p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能</p></li></ul><h2 id="在构造函数中-调用-super-props-的目的是什么" tabindex="-1"><a class="header-anchor" href="#在构造函数中-调用-super-props-的目的是什么" aria-hidden="true">#</a> (在构造函数中)调用 super(props) 的目的是什么</h2><p>在 <code>super() </code>被调用之前，子类是不能使用 构造函数中使用 <code>this</code> 的</p><p>传递 <code>props</code> 给 <code>super()</code> 的原因则是便于(在子类中)能在 <code>constructor</code> 访问 <code>this.props</code></p><h2 id="何为-jsx" tabindex="-1"><a class="header-anchor" href="#何为-jsx" aria-hidden="true">#</a> 何为 JSX</h2><p>JSX是JS的扩展，并拥有 JavaScript 的全部功能</p><p>JSX 生产 React &quot;元素&quot;，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。</p><h2 id="何为纯函数-pure-function" tabindex="-1"><a class="header-anchor" href="#何为纯函数-pure-function" aria-hidden="true">#</a> 何为纯函数(pure function)</h2><p>一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。</p><h2 id="react中的合成事件是什么" tabindex="-1"><a class="header-anchor" href="#react中的合成事件是什么" aria-hidden="true">#</a> React中的合成事件是什么？</h2><p>合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性</p><h2 id="react-中-refs-的作用是什么" tabindex="-1"><a class="header-anchor" href="#react-中-refs-的作用是什么" aria-hidden="true">#</a> React 中 refs 的作用是什么？</h2><p><code>Refs</code> 是 React 提供给我们的安全访问 DOM 元素或者某个React元素的句柄</p><h2 id="类组件-class-component-和函数式组件-functional-component-之间有何不同" tabindex="-1"><a class="header-anchor" href="#类组件-class-component-和函数式组件-functional-component-之间有何不同" aria-hidden="true">#</a> 类组件(Class component)和函数式组件(Functional component)之间有何不同</h2><p><strong>类组件</strong></p><ul><li><p>有自身的状态,直接访问 store 并维持状态</p></li><li><p>有生命周期函数</p></li></ul><p><strong>函数组件</strong></p><ul><li><p>仅是接收 <code>props</code>，并将组件自身渲染到页面时</p></li><li><p>该组件就是一个 <code>无状态组件</code></p></li></ul><h2 id="组件的-状态-state-和属性-props-之间有何不同" tabindex="-1"><a class="header-anchor" href="#组件的-状态-state-和属性-props-之间有何不同" aria-hidden="true">#</a> (组件的)状态(state)和属性(props)之间有何不同</h2><ul><li><p><code>State</code> 是一种数据结构，用于组件挂载时所需数据的默认值。<code>State</code> 由当前组进行管理与维护</p></li><li><p><code>props</code> 由父组件传递给子组件，并且就子组件而言，<code>props</code> 是不可变的(immutable)。组件不能直接改变 <code>props</code></p></li><li><p><code>Props</code> 也不仅仅是数据--回调函数也可以通过 <code>props</code> 传递</p></li></ul><h2 id="何为高阶组件-higher-order-component" tabindex="-1"><a class="header-anchor" href="#何为高阶组件-higher-order-component" aria-hidden="true">#</a> 何为高阶组件(higher order component)</h2><p>高阶组件是一个以组件为参数并返回一个新组件的函数</p><p>如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC</p><h2 id="react-组件的划分业务组件技术组件" tabindex="-1"><a class="header-anchor" href="#react-组件的划分业务组件技术组件" aria-hidden="true">#</a> react 组件的划分业务组件技术组件？</h2><ul><li><p>根据组件的职责通常把组件分为 UI 组件和容器组件。</p></li><li><p>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p></li><li><p>两者通过 React-Redux 提供 connect 方法联系起来。</p></li></ul><h2 id="为什么建议传递给-setstate-的参数是一个-callback-而不是一个对象" tabindex="-1"><a class="header-anchor" href="#为什么建议传递给-setstate-的参数是一个-callback-而不是一个对象" aria-hidden="true">#</a> 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h2><p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state</p><h2 id="应该在-react-组件的何处发起-ajax-请求" tabindex="-1"><a class="header-anchor" href="#应该在-react-组件的何处发起-ajax-请求" aria-hidden="true">#</a> 应该在 React 组件的何处发起 Ajax 请求</h2><p>在 React 组件中，应该在 <code>componentDidMount</code> 中发起网络请求</p><ul><li><p>在组件的生命周期中仅会执行一次</p></li><li><p>你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用</p></li></ul><h2 id="简述-flux-思想" tabindex="-1"><a class="header-anchor" href="#简述-flux-思想" aria-hidden="true">#</a> 简述 flux 思想</h2><p>Flux 的最大特点，就是数据的&quot;单向流动&quot;</p><ul><li><p>View 层通过用户交互（比如 onClick）会触发 Action</p></li><li><p>Dispatcher 会分发触发的 Action 给所有注册的 Store 的回调函数</p></li><li><p>Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了</p></li><li><p>View 会监听这个 change 事件，拿到对应的新数据并调用 setState 更新组件 UI</p></li></ul><h2 id="了解-redux-么-说一下-redux-把" tabindex="-1"><a class="header-anchor" href="#了解-redux-么-说一下-redux-把" aria-hidden="true">#</a> 了解 redux 么，说一下 redux 把</h2><ul><li><p>redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理</p></li><li><p>主要有三个核心方法，<code>action</code>，<code>store</code>，<code>reducer</code></p></li><li><p>工作流程是 <code>view</code> 调用 <code>store</code> 的 <code>dispatch</code> 接收 <code>action</code> 传入 <code>store</code>，<code>reducer</code> 进行 <code>state</code> 操作， <code>view</code> 通过 <code>store</code> 提供的 <code>getState</code> 获取最新的数据</p></li></ul><h2 id="redux-有什么缺点" tabindex="-1"><a class="header-anchor" href="#redux-有什么缺点" aria-hidden="true">#</a> redux 有什么缺点</h2><ul><li><p>一个业务变化就要对应编写 <code>action</code>，<code>reducer</code> 等等</p></li><li><p>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断</p></li></ul>`,64),p=[d];function i(r,n){return a(),o("div",null,p)}const l=e(c,[["render",i],["__file","吱不吱.html.vue"]]);export{l as default};
