import{_ as p,r as t,o as e,c as o,b as n,d as c,a as i,e as s}from"./app-Ald2FT2K.js";const l={},u=s(`<h1 id="吱不吱" tabindex="-1"><a class="header-anchor" href="#吱不吱" aria-hidden="true">#</a> 吱不吱</h1><h2 id="node开发注意点" tabindex="-1"><a class="header-anchor" href="#node开发注意点" aria-hidden="true">#</a> Node开发注意点</h2><h3 id="避免阻塞" tabindex="-1"><a class="header-anchor" href="#避免阻塞" aria-hidden="true">#</a> 避免阻塞</h3><p>在 Node.js 中，有两种类型的线程：一个事件循环线程（也被称为主循环，主线程，事件线程等）。另外一个是在工作线程池里的 k 个工作线程（也被称为线程池）。</p><p><strong>哪种代码运行在事件轮询线程上?</strong></p><p>当 Node.js 程序运行时，程序首先完成初始化部分，即处理 require 加载的模块和注册事件回调。 然后，Node.js 应用程序进入事件循环阶段，通过执行对应回调函数来对客户端请求做出回应。 此回调将同步执行，并且可能在完成之后继续注册新的异步请求。 这些异步请求的回调也会在事件轮询线程中被处理。</p><p>事件循环中同样也包含很多非阻塞异步请求的回调，如网络 I/O。</p><p>总体来说，事件轮询线程执行事件的回调函数，并且负责对处理类似网络 I/O 的非阻塞异步请求</p><p><strong>哪种代码运行在工作线程池?</strong></p><p>Node.js 使用工作线程池来处理“高成本”的任务。 这包括一些操作系统并没有提供非阻塞版本的 I/O 操作，以及一些 CPU 密集型的任务。</p><p>Node.js 模块中有如下这些 API 用到了工作线程池：</p><ul><li><p>I/O 密集型任务：</p><p>-DNS：dns.lookup()，dns.lookupService()。</p><ul><li>文件系统：所有的文件系统 API。除 fs.FSWatcher() 和那些显式同步调用的 API 之外，都使用 libuv 的线程池。</li></ul></li><li><p>CPU 密集型任务：</p><ul><li><p>Crypto：crypto.pbkdf2()、crypto.scrypt()、crypto.randomBytes()、crypto.randomFill()、crypto.generateKeyPair()。</p></li><li><p>Zlib：所有 Zlib 相关函数，除那些显式同步调用的 API 之外，都适用 libuv 的线程池</p></li></ul></li></ul><p>虽然有 Node 有线程池加持提高 I/O 操作的性能，但是仍然只一个主线程（事件循环线程）来统一执行回调。所以如果主线程在处理某一个客户端请求时或回调时被阻塞了，它就无法处理其它客户端的请求了。因为<strong>不要阻塞你的事件轮询线程</strong></p><h4 id="不要阻塞你的事件轮询线程" tabindex="-1"><a class="header-anchor" href="#不要阻塞你的事件轮询线程" aria-hidden="true">#</a> 不要阻塞你的事件轮询线程</h4><p>事件轮询线程关注着每个新的客户端连接，协调产生一个回应。 所有这些进入的请求和输出的应答都要通过事件轮询线程。 这意味着如果你的事件轮询线程在某个地方花费太多的时间，所有当前和未来新的客户端请求都得不到处理机会了</p><p><strong>避免发生的阻塞的基本原则就是：尽量不要产生复杂的计算或循环</strong>，比如下面示例随着 <code>n</code> 的增大，运行时间也会越久</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
<span class="token keyword">let</span> avg <span class="token operator">=</span> sum <span class="token operator">/</span> n<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;avg: &#39;</span> <span class="token operator">+</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果无避免耗时计算使用的时候可以使用一些的优化手段：</p><p><strong>任务拆分</strong></p><p>可以把你的复杂计算拆分开，然后让每个计算分别运行在事件循环中</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">asyncAvg</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> avgCB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Save ongoing sum in JS closure.</span>
  <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">help</span><span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">cb</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// &quot;Asynchronous recursion&quot;.</span>
    <span class="token comment">// Schedule next operation asynchronously.</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token function">help</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Start the helper, with CB to call avgCB.</span>
  <span class="token function">help</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">sum</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">var</span> avg <span class="token operator">=</span> sum<span class="token operator">/</span>n<span class="token punctuation">;</span>
      <span class="token function">avgCB</span><span class="token punctuation">(</span>avg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">asyncAvg</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">avg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;avg of 1-n: &#39;</span> <span class="token operator">+</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方案的缺点是：当前线程都将增加空间和时间开销</p><p><strong>任务分流</strong></p><ul><li><p>通过开发 C++ 插件 的方式使用内置的 Node.js 工作池。使用 N-API。 node-webworker-threads 提供了一个仅用 JavaScript 就可以访问 Node.js 的工作池的方式</p></li><li><p>使用 <code>Child Process</code> 将分配一个进程执行任务，之后通信进程通信获取结果</p></li></ul><p>这类方法的缺点是它增大了通信开销</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><p>Node.js 擅长于 I/O 密集型任务，但对于昂贵的计算，它可能不是最好的选择</p>`,27),r={href:"https://nodejs.org/zh-cn/docs/guides/dont-block-the-event-loop/",target:"_blank",rel:"noopener noreferrer"},d=s(`<h3 id="错误捕获" tabindex="-1"><a class="header-anchor" href="#错误捕获" aria-hidden="true">#</a> 错误捕获</h3><p><strong>与普通页面开发的区别</strong></p><p>开发页面时，每一个用户的浏览器上都有一份JS代码。如果代码在某种情况下崩了，只会对当前用户产生影响，并不会影响其他用户，用户刷新一下即可恢复。而在Node.js中，在不开启多进程的情况下，所有用户的请求，都会走进同一份JS代码，并且只有一个线程在执行这份JS代码。如果某个用户的请求，导致发生错误，Node.js进程挂掉，server端直接就挂了。尽管可能有进程守护，挂掉的进程会被重启，但是在用户请求量大的情况下，错误会被频繁触发，可能就会出现server端不停挂掉，不停重启的情况，对用户体验造成影响</p><p>因此<strong>server端的目标，就是要 快速、可靠 地返回数据</strong></p><p><strong>错误捕获</strong></p><p>除了使用 <code>try...catch</code>， 还可以使用 <code>process</code> 来捕获全局错误，防止进程直接退出，导致后面的请求挂掉。示例代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;uncaughtException&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>err<span class="token punctuation">.</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">\\n</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>err<span class="token punctuation">.</span>stack<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;unhandledRejection&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">reason<span class="token punctuation">,</span> p</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Unhandled Rejection at: Promise </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>p<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> reason: </span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">,</span> reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>uncaughtException：是如果程序中没有正常处理到错误，通过监听 <code>process.on(‘uncaughtException’)</code> 来捕捉错误</p></li><li><p>unhandledRejection：在Node中，Promise中的错误同样不能被 <code>try...catch</code> 和 <code>uncaughtException</code> 捕获。这时候我们就需要 <code>unhandledRejection</code> 来帮我们捕获这部分错误。</p></li></ul><h2 id="在node上处理options请求" tabindex="-1"><a class="header-anchor" href="#在node上处理options请求" aria-hidden="true">#</a> 在node上处理OPTIONS请求</h2><p>学习 cors 跨域问题种，非简单请求时，浏览器会发送一个预请求询问服务端，能否通过同源策略检查，这个预请求是 OPTIONS 类型的。 在使用原生node构建的服务中，需要对 OPTIONS 请求方法进行处理</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;http&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

http
  <span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">&#39;OPTIONS&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token string-property property">&#39;Access-Control-Allow-Origin&#39;</span><span class="token operator">:</span> <span class="token string">&#39;*&#39;</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token string-property property">&#39;Content-Type&#39;</span><span class="token operator">:</span> <span class="token string">&#39;application/json;charset=utf-8&#39;</span><span class="token punctuation">,</span>
      <span class="token string-property property">&#39;Access-Control-Allow-Origin&#39;</span><span class="token operator">:</span> <span class="token string">&#39;*&#39;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">&#39;hello node&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意。在处理 <code>OPTIONS</code> 请求时，也需要设置头部的 <code>Access-Control-Allow-Origin</code> 属性，浏览器也会对 <code>OPTIONS</code> 请求进行同源策略检查。相应的 <code>Access-Control-Allow-Headers</code> 也需要设置非简单请求的头部字段。</p><h2 id="什么是错误优先的回调函数" tabindex="-1"><a class="header-anchor" href="#什么是错误优先的回调函数" aria-hidden="true">#</a> 什么是错误优先的回调函数？</h2><p>错误优先的回调函数用于传递错误和数据。第一个参数始终应该是一个错误对象， 用于检查程序是否发生了错误。其余的参数用于传递数据。例如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//handle the error</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// use the data object</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如何避免回调地狱" tabindex="-1"><a class="header-anchor" href="#如何避免回调地狱" aria-hidden="true">#</a> 如何避免回调地狱</h2><p>你可以有如下几个方法：</p><ul><li><p>模块化：将回调函数分割为独立的函数</p></li><li><p>使用Promises</p></li><li><p>使用<code>yield</code></p></li></ul><h2 id="什么是孤儿进程" tabindex="-1"><a class="header-anchor" href="#什么是孤儿进程" aria-hidden="true">#</a> 什么是孤儿进程？</h2><p>父进程创建子进程之后，父进程退出了，但是父进程对应的一个或多个子进程<strong>还在运行</strong>，这些子进程会被系统的 init 进程收养，对应的进程 ppid 为 1，这就是孤儿进程。通过以下代码示例说明。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// master.js</span>
<span class="token keyword">const</span> fork <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;child_process&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fork<span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;net&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token string">&#39;worker.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

worker<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&#39;server&#39;</span><span class="token punctuation">,</span> server<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;worker process created, pid: %s ppid: %s&#39;</span><span class="token punctuation">,</span> worker<span class="token punctuation">.</span>pid<span class="token punctuation">,</span> process<span class="token punctuation">.</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建子进程之后，主进程退出，此时创建的 worker 进程会成为孤儿进程</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// worker.js</span>
<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;http&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;I am worker, pid: &#39;</span> <span class="token operator">+</span> process<span class="token punctuation">.</span>pid <span class="token operator">+</span> <span class="token string">&#39;, ppid: &#39;</span> <span class="token operator">+</span> process<span class="token punctuation">.</span>ppid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前工作进程 pid 及父进程 ppid</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> worker<span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;message&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">,</span> sendHandle</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>message <span class="token operator">===</span> <span class="token string">&#39;server&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        worker <span class="token operator">=</span> sendHandle<span class="token punctuation">;</span>
        worker<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;connection&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">socket</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            server<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&#39;connection&#39;</span><span class="token punctuation">,</span> socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>控制台进行测试，输出当前工作进程 pid 和 父进程 ppid</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>worker process created<span class="token punctuation">,</span> <span class="token literal-property property">pid</span><span class="token operator">:</span> <span class="token number">32971</span> <span class="token literal-property property">ppid</span><span class="token operator">:</span> <span class="token number">32970</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于在 master.js 里退出了父进程，活动监视器所显示的也就只有工作进程</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-3057196/2o9udya025.jpeg?imageView2/2/w/1620" alt=""></p><p>再次验证，打开控制台调用接口，可以看到工作进程 32971 对应的 ppid 为 1（为 init 进程），此时已经成为了孤儿进程</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>curl http://127.0.0.1:3000
I am worker, pid: 32971, ppid: 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="影响" tabindex="-1"><a class="header-anchor" href="#影响" aria-hidden="true">#</a> 影响</h3><p>init进程就像民政局, 专门负责孤儿进程的善后工作, 每当出现一个孤儿进程的时候,内核会把孤儿进程的父进程设置为init, 而init进程会循环地wait()它已经退出的子进程,这样, 当孤儿进程结束之后, init进程会处理它的善后工作, 因此孤儿进程没有什么危害</p><h2 id="什么是僵尸进程" tabindex="-1"><a class="header-anchor" href="#什么是僵尸进程" aria-hidden="true">#</a> 什么是僵尸进程</h2><p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。任何一个子进程(init除外)在 <code>exit()</code> 之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。一旦有很多只处理少量任务的子进程完成任务后就退出，然后父进程又不管子进程的退出，然后就会产生很多的僵死进程，这样会对程序产生一定的危害</p><h3 id="影响-1" tabindex="-1"><a class="header-anchor" href="#影响-1" aria-hidden="true">#</a> 影响</h3><p>子进程保存的信息(进程号、退出状态、运行时间等)不会释放, 进程号就会一直被占用, 系统能够使用的进程号是有限的,如果产生大量的僵尸进程, 可能会导致系统不能产生新的进程</p><p>严格来说, 僵尸进程并不是问题的根源, 根源是产生大量僵尸进程的父进程, 是父进程没有在子进程 <code>exit()</code> 之后进行处理.如果通过 kill 发送 SIGTERM 信号(kill -15 pid)或者 SIGKILL 信号(kill -9 pid)杀死父进程, 则该父进程产生的僵尸进程就会变成孤儿进程, 这些孤儿进程会被 init 进程接管, init 进程释放这些孤儿进程占用的系统资源</p><h2 id="ipc-通信" tabindex="-1"><a class="header-anchor" href="#ipc-通信" aria-hidden="true">#</a> IPC 通信</h2><p>什么是 IPC 通信，如何建立 IPC 通信？什么场景下需要用到 IPC 通信？</p><p>IPC (Inter-process communication) ，即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现 IPC 的目的就是为了进程之间资源共享访问，实现 IPC 的方式有多种：管道、消息队列、信号量、Domain Socket，Node.js 通过 <code>pipe</code>来实现。</p><p>看一下 Demo，未使用 IPC 的情况</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// pipe.js</span>
<span class="token keyword">const</span> spawn <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;child_process&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>spawn<span class="token punctuation">;</span>
<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">&#39;node&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&#39;worker.js&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>pid<span class="token punctuation">,</span> child<span class="token punctuation">.</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 主进程id3243 子进程3244</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// worker.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;I am worker, PID: &#39;</span><span class="token punctuation">,</span> process<span class="token punctuation">.</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>控制台执行 <code>node pipe.js</code>，输出主进程 id、子进程 id，但是子进程 <code>worker.js</code> 的信息并没有在控制台打印，原因是新创建的子进程有自己的 <code>stdio</code> 流</p><p>创建一个父进程和子进程之间传递消息的 IPC 通道实现输出信息</p><p>修改 <code>pipe.js</code> 让子进程的 <code>stdio</code> 和当前进程的 <code>stdio</code> 之间建立管道链接，还可以通过 <code>spawn()</code> 方法的 <code>stdio</code> 选项建立 IPC 机制，</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> spawn <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;child_process&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>spawn<span class="token punctuation">;</span>
<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">&#39;node&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&#39;worker.js&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
child<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>pid<span class="token punctuation">,</span> child<span class="token punctuation">.</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次验证，控制台执行 <code>node pipe.js</code>，<code>worker.js</code> 的信息也打印了出来</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ 42473 42474
I am worker, PID:  42474
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="关于父进程与子进程是如何通信的" tabindex="-1"><a class="header-anchor" href="#关于父进程与子进程是如何通信的" aria-hidden="true">#</a> 关于父进程与子进程是如何通信的</h3><p>父进程在创建子进程之前会先去创建 IPC 通道并一直监听该通道，之后开始创建子进程并通过环境变量（NODECHANNELFD）的方式将 IPC 通道的文件描述符传递给子进程，子进程启动时根据传递的文件描述符去链接 IPC 通道，从而建立父子进程之间的通信机制</p><h2 id="node为什么是单线程" tabindex="-1"><a class="header-anchor" href="#node为什么是单线程" aria-hidden="true">#</a> Node为什么是单线程</h2><p>Javascript 为什么是单线程？这个问题需要从浏览器说起，在浏览器环境中对于 DOM 的操作，试想如果多个线程来对同一个 DOM 操作是不是就乱了呢，那也就意味着对于DOM的操作只能是单线程，避免 DOM 渲染冲突。在浏览器环境中 UI 渲染线程和 JS 执行引擎是互斥的，一方在执行时都会导致另一方被挂起，这是由 JS 引擎所决定的</p><h2 id="如何让一个-js-文件在-linux-下成为一个可执行命令程序" tabindex="-1"><a class="header-anchor" href="#如何让一个-js-文件在-linux-下成为一个可执行命令程序" aria-hidden="true">#</a> 如何让一个 js 文件在 Linux 下成为一个可执行命令程序</h2><ol><li><p>新建 hello.js 文件，头部须加上 <code>#!/usr/bin/env node</code>，表示当前脚本使用 Node.js 进行解析</p></li><li><p>赋予文件可执行权限 <code>chmod +x chmod +x /\${dir}/hello.js</code>，目录自定义</p></li><li><p>在 <code>/usr/local/bin</code> 目录下创建一个软链文件 <code>sudo ln-s/\${dir}/hello.js/usr/local/bin/hello</code>，文件名就是我们在终端使用的名字</p></li><li><p>终端执行 hello 相当于输入 <code>node hello.js</code></p></li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#!/usr/bin/env node

console.log(&#39;hello world!&#39;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>终端测试</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ hello
hello world
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="进程的当前工作目录是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#进程的当前工作目录是什么-有什么作用" aria-hidden="true">#</a> 进程的当前工作目录是什么? 有什么作用?</h2><p>进程的当前工作目录可以通过 <code>process.cwd()</code> 命令获取，默认为当前启动的目录，如果是创建子进程则继承于父进程的目录，可通过 <code>process.chdir()</code> 命令重置，例如通过 <code>spawn</code> 命令创建的子进程可以指定 <code>cwd</code> 选项设置子进程的工作目录。</p><p>有什么作用？例如，通过 fs 读取文件，如果设置为相对路径则相对于当前进程启动的目录进行查找，所以，启动目录设置有误的情况下将无法得到正确的结果。还有一种情况程序里引用第三方模块也是根据当前进程启动的目录来进行查找的。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>process<span class="token punctuation">.</span><span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">&#39;/Users/may/Documents/test/&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 设置当前进程目录</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程目录</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="console-log-是同步还是异步-如何实现一个-console-log" tabindex="-1"><a class="header-anchor" href="#console-log-是同步还是异步-如何实现一个-console-log" aria-hidden="true">#</a> console.log 是同步还是异步? 如何实现一个 console.log？</h3><p><code>console.log</code> 内部实现是 <code>process.stdout</code>，将输入的内容打印到 stdout，异步同步取决于 stdout 连接的数据流的类型（需要写入的位置）以及不同的操作系统。</p><ul><li><p>文件：在 Windows 和 POSIX 上是同步的；</p></li><li><p>TTY（终端）：在 Windows 上是异步的，在 POSIX 上是同步；</p></li><li><p>管道（和 socket）：在 Windows 上是同步的，在 POSIX 上是异步的；</p></li></ul><p>造成这种差异的原因是因为一些历史遗留问题，不过这个问题并不会影响正常的输出结果。</p>`,64);function k(v,m){const a=t("ExternalLinkIcon");return e(),o("div",null,[u,n("blockquote",null,[n("p",null,[n("a",r,[c("不要阻塞你的事件循环（或是工作线程池）"),i(a)])])]),d])}const b=p(l,[["render",k],["__file","吱不吱.html.vue"]]);export{b as default};
