import{_ as p,r as t,o,c,b as n,d as s,a as i,e as a}from"./app-Ald2FT2K.js";const l="/lanjz/assets/renshi-3-G5pCAImc.jpeg",d="/lanjz/assets/renshi-2-hAx6ZwPh.jpeg",u="/lanjz/assets/renshi-1-q9CqCz2T.jpeg",r="/lanjz/assets/renshi_5-26SdT3iR.png",k="/lanjz/assets/node-1-RxexuB9P.png",v="/lanjz/assets/node-2-ag2FhGEt.png",m="/lanjz/assets/renshi-4-W80yyg0a.jpeg",b={},h=a('<h1 id="认识node" tabindex="-1"><a class="header-anchor" href="#认识node" aria-hidden="true">#</a> 认识Node</h1><p>作为一个异步事件驱动的 JavaScript 运行时，Node.js 被设计用来构建可扩展的网络应用，同时使用了一个非阻塞式I/O 的模型，使其轻量又高效</p><p>这里出现了两个关键词：事件驱动和非阻塞式I/O，所以要认识 Node 得先理解这两个是什么意思</p><h2 id="事件驱动" tabindex="-1"><a class="header-anchor" href="#事件驱动" aria-hidden="true">#</a> 事件驱动</h2><p>事件驱动是一种编程模型，编程模型是指操作系统在处理 IO 时所采用的方式，这通常是为了解决 IO 速度比较慢的问题而诞生的</p><p>事件驱动模型无需为每一个请求创建额外的线程，事件驱动编程是使用协作式处理任务，而不是多线程的抢占式。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理</p><p>我们把每一个 I/O 任务都当作是一个事件，在事件驱动模型中，每一个I/O操作都会被添加到事件队列中，主线程循环地处理队列上的工作任务，当执行过程中遇到阻塞（读取文件、查询数据库）时，线程不会停下来等待结果，而是继续执行队列中的下一个任务。当阻塞的事件完成时会将回调添加到事件队列中，待下一次事件循环中将取出执行</p><p>为了更好理解事件驱动模型，顺便了解一下其它的编程模型</p><h3 id="其它编程模型" tabindex="-1"><a class="header-anchor" href="#其它编程模型" aria-hidden="true">#</a> 其它编程模型</h3><p>除了上面讲的事件驱动编程模型，还有同步式模型，多进程模型，多线程模型</p><h4 id="同步式模型" tabindex="-1"><a class="header-anchor" href="#同步式模型" aria-hidden="true">#</a> 同步式模型</h4><p>同步式模型就是每次值处理一个请求，迭代地将所有请求处理完毕。无并发可言，处理效率当然很低</p><h4 id="多进程模型" tabindex="-1"><a class="header-anchor" href="#多进程模型" aria-hidden="true">#</a> 多进程模型</h4><p>每收到一个用户请求，就开启一个进程去处理</p><p><strong>优点</strong></p><ul><li><p>每个进程互相独立，子进程崩溃没关系</p></li><li><p>通过增加CPU，就可以容易扩充性能</p></li><li><p>充分利用系统资源</p></li></ul><p><strong>缺点</strong></p><ul><li><p>各个进程地址空间相互隔离，这一优点也会变成缺点，那就是进程间要想通信就会变得比较困难</p></li><li><p>进程开销是比线程要大的，频繁的创建销毁进程无疑会加重系统负担。</p></li></ul><h4 id="多线程模型" tabindex="-1"><a class="header-anchor" href="#多线程模型" aria-hidden="true">#</a> 多线程模型</h4><p>每个用户请求，开一个线程去处理。由于线程共享进程地址空间，因此线程间通信天然不需要借助任何通信机制，直接读取内存就好了</p><p><strong>优点</strong></p><ul><li><p>为每个请求创建一个线程，即使一个线程因执行I/O操作——比如读取数据库等——被阻塞暂停运行也不会影响到其它线程</p></li><li><p>所有线程可以直接共享内存和变量等</p></li><li><p>线程方式消耗的总资源比进程方式好</p></li></ul><p><strong>缺点</strong></p><ul><li><p>线程之间的同步和加锁控制比较麻烦</p></li><li><p>一个线程的崩溃可能影响到整个程序的稳定性</p></li><li><p>虽然线程创建开销相比进程小，但依然也是有开销的</p></li></ul><h2 id="非阻塞i-o" tabindex="-1"><a class="header-anchor" href="#非阻塞i-o" aria-hidden="true">#</a> 非阻塞I/O</h2><p>Node 在 I/O 操作方面性能是十分高效的，因为 Node 使用的是：异步+非阻塞I/O操作。那么到底怎么理解异步+非阻塞？异步跟非阻塞感觉像是同一个意思，具体怎么区分？</p><h3 id="什么是-i-o-操作" tabindex="-1"><a class="header-anchor" href="#什么是-i-o-操作" aria-hidden="true">#</a> 什么是 I/O 操作</h3><p>首先所谓的阻塞/非阻塞通常是针对 I/O 操作的，所以得先明白什么是 I/O 操作? 输入/输出（I/O）是在内存和外部设备（如磁盘，终端和网络）之间复制数据的过程。不仅仅是文件读写，包括键盘输入，网络请求等都属于 I/O 操作</p><p>以读取文件为例，一个完整的 I/O 操作包括：系统内核完成磁盘寻道 -&gt; 读取数据 -&gt; 复制数据到内存这些步聚</p><p><strong>在Node中，I/O特指 Node 程序在 Libuv 支持下与系统磁盘和网络交互的过程</strong></p><p>如何进行 I/O 操作，整体分为阻塞型 I/O 和非阻塞型 I/O 两种</p><h3 id="阻塞-非阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞-非阻塞" aria-hidden="true">#</a> 阻塞/非阻塞</h3><p><strong>阻塞型 I/O</strong>是指在调用 I/O 操作后，应用程序需要等待 I/O 完成并返回结果，然后才能进行之后的其它任务</p><p><strong>非阻塞I/O</strong>则是调用I/O 操作后，不用等待结果直接返回。但是不带结果返回的话应用程序怎么获取结果呢？此时就需要通过类似轮循的方式不断得去读取 I/O 操作是否有结果</p><p>所以到目前为止所谓的非阻塞 I/O 并不理想，因为执行这种非阻塞 I/O 后，虽然 CPU 的时间片可以用来处理其他事务提高了性能，但是仍需要不断得轮循，这会造成 CPU 浪费。我们期望是理想操作是发起 I/O 操作后无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在 I/O 完成后通过信号或回调将数据传递给应用程序即可，如下面示意图</p><p><img src="'+l+'" alt=""></p><h3 id="异步-非阻塞" tabindex="-1"><a class="header-anchor" href="#异步-非阻塞" aria-hidden="true">#</a> 异步+非阻塞</h3><p>前面主要是从单线程场景考虑这很难达到理想的 I/O 操作，但如果是多线程就可以。通过让部分线程进行阻塞 I/O 或非阻塞I/O + 轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，这就实现我们想要的 I/O 操作，也就是<strong>异步I/O 操作</strong></p><p>Node 的异步非阻塞 I/O 就是这么个意思了，通过多线程来执行非阻塞I/O来达到高效的 I/O 处理。所以说 Node 其实是多线程的，平时说的单线程是指我们的 JS 代码执行在单线程中</p><p>上文提到 Node 底层仍是利用了多线程进行 I/O 处理，多线程的实现根据平台不同有各自的实现方法。在 *nix 平台下 Node 使用自定义的线程池来实现 异步I/O 操作，在Window 平台下使用其自有 IOCP 来实现I/O 。因此为了解决平台的兼容差异问题，所以 Node 提供了 libuv 作为抽象封装层，所有平台兼容性的判断都由这一层完成</p><h3 id="异步i-o的过程" tabindex="-1"><a class="header-anchor" href="#异步i-o的过程" aria-hidden="true">#</a> 异步I/O的过程</h3><p>完成整个异步I/O 操作需要事件循环，观察者，请求对象和线程池等配合完成</p><p><strong>事件循环</strong></p><p>类似浏览器中的事件循环，每一次循环都会查找是否有完成的事件，有的话就取出执行，事件循环怎么查找呢？从观察者队列中查找</p><p><strong>观察者</strong></p><p>观察者的作用就是观察，观察啥？观察是否有完成的 I/O 事件，观察者根据 I/O 类型也分成：文件I/O 观察者，网络I/O 观察者等，在每一次的事件循环中，观察都会通过API获取是否有完成的I/O事件，有的话就添加的自己的观察者队列中</p><p><strong>请求对象</strong></p><p>JS执行 I/O操作 时实际上是通过底层的 libuv 进行系统调用的，此时 libuv 会创建一个请求对象，我们要执行的方法，参数和回调都会包装在这个请求对象中，然后将这个请求推入到线程池，等待线程池处理</p><p><strong>线程池</strong></p><p>上面提到了包装完请求对象后就会推入线程池，交于线程池来执行具体的I/O操作</p><h4 id="粟子" tabindex="-1"><a class="header-anchor" href="#粟子" aria-hidden="true">#</a> 粟子</h4><p>接下来通过 <code>fs.open()</code> 方法来概述一下 Node 和底层之间是如何执行异步 I/O 的</p><ol><li><p>JS 调用 Node 的核心模块执行 <code>open()</code> 方法，即 <code>fs.open()</code> 方法</p></li><li><p>核心模块内部调用 C++ 内建模块</p></li><li><p>内建模块通过 libuv 进行系统调用</p><p>libuv 作为封装层，有两个平台的实现，无论怎样实际上是调用了 <code>uv_fs_open()</code> 方法</p><p><img src="'+d+'" alt=""></p></li><li><p>调用 <code>uv_fs_open</code> 的过程中会创建一个请求对象，从JS传入的参数，回调和当前方法都会包装到这个请求对象中，然后将这个请求对象推入到线程池中，当线程池有可用线程时，就会根据请求对象调用具体的方法。至此 JS 调用就结束了，JS所在线程可以继续执行后续操作</p></li><li><p>当线程池中 I/O 操作完成之后，就会通过 IOCP，告知当前对象操作已经完成</p></li><li><p>之后事件循环的每一次 tick 中，观察者都会检查是否有完成的请求对象，如果存在，会将请求对象加入到 I/O 观察者队列中，下一次事件循环的时候就会从队列中取出当作事件执行</p></li></ol><p>整个过程的示意图：</p><p><img src="'+u+'" alt=""></p><h3 id="非i-o的异步api" tabindex="-1"><a class="header-anchor" href="#非i-o的异步api" aria-hidden="true">#</a> 非I/O的异步API</h3><p>非I/O的异步API是指 <code>setTimeout()</code>,<code>setInterval()</code>, <code>setImmediate()</code> 和 <code>process.next()</code></p><p><strong><code>setTimeout</code>和<code>setInterval</code></strong></p><p><code>setTimeout()</code> 和 <code>setInterval()</code> 实现原理与 I/O 比较类似，只是不需要线程池参与。调用<code>setTimeout()</code> 和 <code>setInterval()</code> 时创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次 Tick 执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。如下示意图</p><p><img src="'+r+`" alt=""></p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>定时器并非精准的，因为可能在一次 Tick 中在触发定时回调之前有耗时的任务，这样导致定时器延时执行</p></div><p><strong><code>process.nextTick()</code></strong></p><p><code>process.nextTick()</code> 的意思就是定义出一个异步动作，并且这个动作在事件循环当前阶段结束后执行</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>           ┌───────────────────────────┐
        ┌─&gt;│           timers          │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        │  │     pending callbacks     │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        |  |     idle, prepare         │
        |  └─────────────┬─────────────┘
  nextTickQueue     nextTickQueue
        |  ┌─────────────┴─────────────┐
        |  │           poll            │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        │  │           check           │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        └──┤       close callbacks     │
           └───────────────────────────┘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><code>setImmediate()</code></strong></p><p><code>setImmediate()</code> 定义出一个异步动作事件会在当前事件循环中的 check 阶段被执行</p><h2 id="同步-异步" tabindex="-1"><a class="header-anchor" href="#同步-异步" aria-hidden="true">#</a> 同步/异步</h2><p>同步和异步描述的是进程/线程的调用方式</p><p>同步调用指的是进程/线程发起调用后，一直等待调用返回后才继续执行下一步操作，这并不代表 CPU 在这段时间内也会一直等待，操作系统多半会切换到其它的进程/线程中，等到调用返回后再切换回原来的进程/线程</p><p>异步就相反，发起调用后，进程/线程继续向下执行，当调用返回后，通过某种手段来通过知调用者</p><h2 id="node-架构" tabindex="-1"><a class="header-anchor" href="#node-架构" aria-hidden="true">#</a> Node 架构</h2><p>上面提到 Node 底层是支持多线程的，依靠多线程的支持实现了高效异步 I/O 操作，接下就捊捊Node 整体架构。</p><p>Nodejs 的运行依赖于 V8 引擎和 libuv 库</p><ul><li><p>V8：执行 JS 的引擎. 也就是翻译 JS. 包括我们熟悉的编译优化, 垃圾回收等等.</p></li><li><p>libuv: 是操作系统 API 层的一个抽象层，Node 通过它实现了异步非阻塞 I/O</p></li></ul><p>那么 Nodejs 如何组织它们呢? 如下图:</p><p><img src="`+k+'" alt=""></p><p>Nodejs 通过一层 <code>C++ Binding</code>, 把 JS 传入 V8, V8 解析后交给 libuv 发起 <code>asnyc I/O</code>, 并结合事件循环进行调度. 再看看下面的图:</p><p><img src="'+v+'" alt=""></p><h3 id="io调用的结果怎么返回给调用的进程-线程" tabindex="-1"><a class="header-anchor" href="#io调用的结果怎么返回给调用的进程-线程" aria-hidden="true">#</a> IO调用的结果怎么返回给调用的进程/线程</h3><p>通过内核进程复制给调用进程，在 Linux 下，用户进程没办法直接访问内核空间，通常是内核调用 <code>copy_to_user</code> 方法来传递数据的。大致的流程是 IO 的数据会先被内核空间读取，然后内核将数据复制给用户进程。还有一种零复制技术，大致是内核进程和用户进程共享一块内存地址，这避免了内存的复制</p><h3 id="libuv" tabindex="-1"><a class="header-anchor" href="#libuv" aria-hidden="true">#</a> libuv</h3><p>上文提到过为了实现异步的 I/O 操作，需要实现线程池，最初 Node 在 *nix 平台下采用了 libeio 配合 libev 实现了异步 I/O，在Node v0.9.3 中，自行实现了线程池来完成异步 I/O；而在 Window 下则是使用了 IOCP，它在某种程度上提供了理想的异步 I/O ，它的内部其实仍然是线程池原理</p><p>由于 Window 和 *inx 平台的差异，Node 提供了 libuv 作为抽象封装层，使得所有平台兼容性的判断都在这一层来完成，并保证上层的 Node 与下层的自定义线池及 IOCP 之间各自独立</p><p>所以 Node 的异步 I/O 调用是由libuv来支持的，以 <code>readFile</code> 为例，读取文件的系统调用是由libuv来完成的，Node只负责调用libuv 的接口，等数据返回后再执行对应的回调方法</p><blockquote><p>线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源</p></blockquote><p><img src="'+m+`" alt=""></p><h2 id="高并发的node" tabindex="-1"><a class="header-anchor" href="#高并发的node" aria-hidden="true">#</a> 高并发的Node</h2><ul><li><p>并发：两排队伍在排队，但是只有一个买票窗口</p></li><li><p>并行：两个队伍在排，而且有两个买票窗口</p></li></ul><p><strong>Node中的并发</strong></p><p>单线程支持高并发，通常都是依靠异步+事件驱动（循环）来实现的，异步使得代码在面临多个请求时不会发生阻塞，事件循环提供了IO调用结束后调用回调函数的能力</p><p>先来看一个例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// helper</span>
<span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">time</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;延时：&#39;</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> time <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    delay<span class="token punctuation">,</span>
    fibonacci
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;koa&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> Router <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;@koa/router&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> delay<span class="token punctuation">,</span> fibonacci <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./helper&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">timeLog</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">开始处理时间：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>start<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;结束时间：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>end<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;处理时长：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>end <span class="token operator">-</span> start<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;/delay&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token function">timeLog</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;/fibonacci&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token function">timeLog</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;/&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token function">timeLog</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  app
    <span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span><span class="token function">allowedMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;去吧 皮卡丘：3000&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中 <code>delay(6)</code> 是一个用定时器 <code>setTimeout</code> 做的延迟函数。当我们在浏览器输入 <code>localhost:3000/delay</code> 因为延迟的关系并不会立马取到返回值，紧接着在新的 <code>Tab</code> 页输入 <code>localhost:3000/</code> 可以立马显示返回的内容，并没有被之前的 <code>localhost:3000/delay</code> 请求所阻塞</p><p>另个场景先在浏览器输入 <code>localhost:3000/fibonacci</code>，这是一个 <code>fibonacci</code> 需要点时间，之后在新的 <code>Tab</code> 页输入 <code>localhost:3000/</code> 并没有显示内容而是之前的请求阻塞了</p><p>那么 Node 在哪些场景下是非阻塞的？ 处理 IO 操作的时候，这个 IO 包括数据库操作（连接数，机器性能等）、缓存服务、网络IO、文件读写等操作。</p>`,96),g={href:"https://cnodejs.org/topic/5c8b0a4a7ce0df3732428254",target:"_blank",rel:"noopener noreferrer"},I=a('<p>CPU密集型本身就不适合 nodejs，但非常适合大量 io 操作的情况</p><p>假设一个请求流程 需要 <code>10ms</code> 的简单运算，<code>900ms</code> 的数据库查询，<code>90ms</code> 的数据返回。完整时间是1s</p><p>如果是 java 处理</p><p>如果是 <code>1000</code> 个请求，不在考虑数据库压力的情况下，理论上 java 会并发产生 <code>1000</code> 个线程来处理，理论上也就可以在 <code>1s</code> 内处理完 <code>1000</code> 个请求并全部返回数据。但是为了这 <code>1000</code> 个线程，服务器可能产生了 <code>百分之80</code> 的资源消耗，也就是说你这台服务器能支撑 <code>1000</code> 个并发已经很好了。</p><p>如果是 nodejs 处理</p><p>如果 <code>1000</code> 个请求，从第一个请求开始，<code>10ms</code> 处理完成，然后就交给数据去处理了，这个时候就可以处理下一个 <code>10ms</code> 的请求。也就是需要 <code>10s</code> 才可以接收完所有的请求，但是第一个请求返回时间是 <code>1s</code>，第二个请求返回时间是 <code>1s+10ms</code>，以此类推，但是这 <code>1000</code> 个并发 nodejs 会在 <code>11s</code> 左右全部处理完</p><p>你可能觉得 java 是 <code>1s</code>，nodejs 是 <code>11s</code>，差距很大，但是需要注意的是服务器消耗</p><p>java 是 <code>1000</code> 个进程可能已经是服务器的极限看了，但是 nodejs 服务器确一点事情都没有。换而言之，我一台服务器打开 <code>10</code> 个 nodejs 进程，我一台服务器就可以处理的并发是 <code>10s，1W</code> 的，但是 java 确实 <code>1s，1000</code>, 我需要用10台服务器才完成。</p><p>实际工作中，我们会发现。在相同的业务需求下，io 密集型的需求，使用 nodejs 同一台服务器可以处理的并发量更大，当然，牺牲了一部分的时间。但是这个完全可以用多开进程的方式来弥补来达到一个均衡。同样的服务器，仅 io 密集型的需求而言，nodejs 更加合适。</p><p>但是如果是 cpu 密集型的你 java 开 <code>1000</code> 个线程，是并发计算的，一个计算 <code>1</code> 秒， <code>1000</code> 的线程也 <code>1</code> 秒返回了，但是使用 nodejs，你需要 <code>1000</code> 秒才可以返回。</p><p><strong>node 在处理 IO 操作时是非阻塞的，处理 CPU 密集型计算时会阻塞的</strong></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>Node 为什么是高性能的？</p><ol><li><p>Node 采用事件驱动的方式处理请求，无须为每个请求创建额外的线程 ，可以省掉创建线程和销毁线程的开销</p></li><li><p>Node 底层又是具有线程池的，依靠 Libuv 线程池 Node 可以实现异步 I/O 操作</p></li></ol>',14);function O(f,x){const e=t("ExternalLinkIcon");return o(),c("div",null,[h,n("p",null,[n("strong",null,[s("引用 "),n("a",g,[s("CNODE 社区 - 关于 Nodejs 服务器高并发的疑问"),i(e)]),s(" 中的一个评论来帮助理解 node 高并发的适合场景")])]),I])}const _=p(b,[["render",O],["__file","认识Node.html.vue"]]);export{_ as default};
